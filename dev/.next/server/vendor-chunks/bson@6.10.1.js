"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson@6.10.1";
exports.ids = ["vendor-chunks/bson@6.10.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/bson@6.10.1/node_modules/bson/lib/bson.cjs":
/*!************************************************************************!*\
  !*** ../node_modules/.pnpm/bson@6.10.1/node_modules/bson/lib/bson.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst TypedArrayPrototypeGetSymbolToStringTag = (() => {\n    const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;\n    return (value) => g.call(value);\n})();\nfunction isUint8Array(value) {\n    return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\nfunction isAnyArrayBuffer(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.toStringTag in value &&\n        (value[Symbol.toStringTag] === 'ArrayBuffer' ||\n            value[Symbol.toStringTag] === 'SharedArrayBuffer'));\n}\nfunction isRegExp(regexp) {\n    return regexp instanceof RegExp || Object.prototype.toString.call(regexp) === '[object RegExp]';\n}\nfunction isMap(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.toStringTag in value &&\n        value[Symbol.toStringTag] === 'Map');\n}\nfunction isDate(date) {\n    return date instanceof Date || Object.prototype.toString.call(date) === '[object Date]';\n}\nfunction defaultInspect(x, _options) {\n    return JSON.stringify(x, (k, v) => {\n        if (typeof v === 'bigint') {\n            return { $numberLong: `${v}` };\n        }\n        else if (isMap(v)) {\n            return Object.fromEntries(v);\n        }\n        return v;\n    });\n}\nfunction getStylizeFunction(options) {\n    const stylizeExists = options != null &&\n        typeof options === 'object' &&\n        'stylize' in options &&\n        typeof options.stylize === 'function';\n    if (stylizeExists) {\n        return options.stylize;\n    }\n}\n\nconst BSON_MAJOR_VERSION = 6;\nconst BSON_VERSION_SYMBOL = Symbol.for('@@mdb.bson.version');\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\n\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return 'BSONError';\n    }\n    constructor(message, options) {\n        super(message, options);\n    }\n    static isBSONError(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            'bsonError' in value &&\n            value.bsonError === true &&\n            'name' in value &&\n            'message' in value &&\n            'stack' in value);\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return 'BSONVersionError';\n    }\n    constructor() {\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return 'BSONRuntimeError';\n    }\n    constructor(message) {\n        super(message);\n    }\n}\nclass BSONOffsetError extends BSONError {\n    get name() {\n        return 'BSONOffsetError';\n    }\n    constructor(message, offset, options) {\n        super(`${message}. offset: ${offset}`, options);\n        this.offset = offset;\n    }\n}\n\nlet TextDecoderFatal;\nlet TextDecoderNonFatal;\nfunction parseUtf8(buffer, start, end, fatal) {\n    if (fatal) {\n        TextDecoderFatal ??= new TextDecoder('utf8', { fatal: true });\n        try {\n            return TextDecoderFatal.decode(buffer.subarray(start, end));\n        }\n        catch (cause) {\n            throw new BSONError('Invalid UTF-8 string in BSON document', { cause });\n        }\n    }\n    TextDecoderNonFatal ??= new TextDecoder('utf8', { fatal: false });\n    return TextDecoderNonFatal.decode(buffer.subarray(start, end));\n}\n\nfunction tryReadBasicLatin(uint8array, start, end) {\n    if (uint8array.length === 0) {\n        return '';\n    }\n    const stringByteLength = end - start;\n    if (stringByteLength === 0) {\n        return '';\n    }\n    if (stringByteLength > 20) {\n        return null;\n    }\n    if (stringByteLength === 1 && uint8array[start] < 128) {\n        return String.fromCharCode(uint8array[start]);\n    }\n    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);\n    }\n    if (stringByteLength === 3 &&\n        uint8array[start] < 128 &&\n        uint8array[start + 1] < 128 &&\n        uint8array[start + 2] < 128) {\n        return (String.fromCharCode(uint8array[start]) +\n            String.fromCharCode(uint8array[start + 1]) +\n            String.fromCharCode(uint8array[start + 2]));\n    }\n    const latinBytes = [];\n    for (let i = start; i < end; i++) {\n        const byte = uint8array[i];\n        if (byte > 127) {\n            return null;\n        }\n        latinBytes.push(byte);\n    }\n    return String.fromCharCode(...latinBytes);\n}\nfunction tryWriteBasicLatin(destination, source, offset) {\n    if (source.length === 0)\n        return 0;\n    if (source.length > 25)\n        return null;\n    if (destination.length - offset < source.length)\n        return null;\n    for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {\n        const char = source.charCodeAt(charOffset);\n        if (char > 127)\n            return null;\n        destination[destinationOffset] = char;\n    }\n    return source.length;\n}\n\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (() => {\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    }\n    catch {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType(potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);\n    },\n    allocate(size) {\n        return Buffer.alloc(size);\n    },\n    allocateUnsafe(size) {\n        return Buffer.allocUnsafe(size);\n    },\n    equals(a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray(array) {\n        return Buffer.from(array);\n    },\n    fromBase64(base64) {\n        return Buffer.from(base64, 'base64');\n    },\n    toBase64(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');\n    },\n    fromISO88591(codePoints) {\n        return Buffer.from(codePoints, 'binary');\n    },\n    toISO88591(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');\n    },\n    fromHex(hex) {\n        return Buffer.from(hex, 'hex');\n    },\n    toHex(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');\n    },\n    toUTF8(buffer, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        const string = nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end);\n        if (fatal) {\n            for (let i = 0; i < string.length; i++) {\n                if (string.charCodeAt(i) === 0xfffd) {\n                    parseUtf8(buffer, start, end, true);\n                    break;\n                }\n            }\n        }\n        return string;\n    },\n    utf8ByteLength(input) {\n        return Buffer.byteLength(input, 'utf8');\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        const latinBytesWritten = tryWriteBasicLatin(buffer, source, byteOffset);\n        if (latinBytesWritten != null) {\n            return latinBytesWritten;\n        }\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');\n    },\n    randomBytes: nodejsRandomBytes,\n    swap32(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).swap32();\n    }\n};\n\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (() => {\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === 'function') {\n        return (byteLength) => {\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    }\n    else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType(potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ??\n            Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === 'Uint8Array') {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);\n    },\n    allocate(size) {\n        if (typeof size !== 'number') {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    allocateUnsafe(size) {\n        return webByteUtils.allocate(size);\n    },\n    equals(a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < a.byteLength; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray(array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64(base64) {\n        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n    },\n    toBase64(uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591(codePoints) {\n        return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n    },\n    toISO88591(uint8array) {\n        return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n    },\n    fromHex(hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for (let i = 0; i < evenLengthHex.length; i += 2) {\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex(uint8array) {\n        return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n    },\n    toUTF8(uint8array, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        return parseUtf8(uint8array, start, end, fatal);\n    },\n    utf8ByteLength(input) {\n        return new TextEncoder().encode(input).byteLength;\n    },\n    encodeUTF8Into(uint8array, source, byteOffset) {\n        const bytes = new TextEncoder().encode(source);\n        uint8array.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes,\n    swap32(buffer) {\n        if (buffer.length % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n        for (let i = 0; i < buffer.length; i += 4) {\n            const byte0 = buffer[i];\n            const byte1 = buffer[i + 1];\n            const byte2 = buffer[i + 2];\n            const byte3 = buffer[i + 3];\n            buffer[i] = byte3;\n            buffer[i + 1] = byte2;\n            buffer[i + 2] = byte1;\n            buffer[i + 3] = byte0;\n        }\n        return buffer;\n    }\n};\n\nconst hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\n\nclass BSONValue {\n    get [BSON_VERSION_SYMBOL]() {\n        return BSON_MAJOR_VERSION;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        return this.inspect(depth, options, inspect);\n    }\n}\n\nconst FLOAT = new Float64Array(1);\nconst FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);\nFLOAT[0] = -1;\nconst isBigEndian = FLOAT_BYTES[7] === 0;\nconst NumberUtils = {\n    isBigEndian,\n    getNonnegativeInt32LE(source, offset) {\n        if (source[offset + 3] > 127) {\n            throw new RangeError(`Size cannot be negative at offset: ${offset}`);\n        }\n        return (source[offset] |\n            (source[offset + 1] << 8) |\n            (source[offset + 2] << 16) |\n            (source[offset + 3] << 24));\n    },\n    getInt32LE(source, offset) {\n        return (source[offset] |\n            (source[offset + 1] << 8) |\n            (source[offset + 2] << 16) |\n            (source[offset + 3] << 24));\n    },\n    getUint32LE(source, offset) {\n        return (source[offset] +\n            source[offset + 1] * 256 +\n            source[offset + 2] * 65536 +\n            source[offset + 3] * 16777216);\n    },\n    getUint32BE(source, offset) {\n        return (source[offset + 3] +\n            source[offset + 2] * 256 +\n            source[offset + 1] * 65536 +\n            source[offset] * 16777216);\n    },\n    getBigInt64LE(source, offset) {\n        const lo = NumberUtils.getUint32LE(source, offset);\n        const hi = NumberUtils.getUint32LE(source, offset + 4);\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    },\n    getFloat64LE: isBigEndian\n        ? (source, offset) => {\n            FLOAT_BYTES[7] = source[offset];\n            FLOAT_BYTES[6] = source[offset + 1];\n            FLOAT_BYTES[5] = source[offset + 2];\n            FLOAT_BYTES[4] = source[offset + 3];\n            FLOAT_BYTES[3] = source[offset + 4];\n            FLOAT_BYTES[2] = source[offset + 5];\n            FLOAT_BYTES[1] = source[offset + 6];\n            FLOAT_BYTES[0] = source[offset + 7];\n            return FLOAT[0];\n        }\n        : (source, offset) => {\n            FLOAT_BYTES[0] = source[offset];\n            FLOAT_BYTES[1] = source[offset + 1];\n            FLOAT_BYTES[2] = source[offset + 2];\n            FLOAT_BYTES[3] = source[offset + 3];\n            FLOAT_BYTES[4] = source[offset + 4];\n            FLOAT_BYTES[5] = source[offset + 5];\n            FLOAT_BYTES[6] = source[offset + 6];\n            FLOAT_BYTES[7] = source[offset + 7];\n            return FLOAT[0];\n        },\n    setInt32BE(destination, offset, value) {\n        destination[offset + 3] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset] = value;\n        return 4;\n    },\n    setInt32LE(destination, offset, value) {\n        destination[offset] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 3] = value;\n        return 4;\n    },\n    setBigInt64LE(destination, offset, value) {\n        const mask32bits = BigInt(0xffff_ffff);\n        let lo = Number(value & mask32bits);\n        destination[offset] = lo;\n        lo >>= 8;\n        destination[offset + 1] = lo;\n        lo >>= 8;\n        destination[offset + 2] = lo;\n        lo >>= 8;\n        destination[offset + 3] = lo;\n        let hi = Number((value >> BigInt(32)) & mask32bits);\n        destination[offset + 4] = hi;\n        hi >>= 8;\n        destination[offset + 5] = hi;\n        hi >>= 8;\n        destination[offset + 6] = hi;\n        hi >>= 8;\n        destination[offset + 7] = hi;\n        return 8;\n    },\n    setFloat64LE: isBigEndian\n        ? (destination, offset, value) => {\n            FLOAT[0] = value;\n            destination[offset] = FLOAT_BYTES[7];\n            destination[offset + 1] = FLOAT_BYTES[6];\n            destination[offset + 2] = FLOAT_BYTES[5];\n            destination[offset + 3] = FLOAT_BYTES[4];\n            destination[offset + 4] = FLOAT_BYTES[3];\n            destination[offset + 5] = FLOAT_BYTES[2];\n            destination[offset + 6] = FLOAT_BYTES[1];\n            destination[offset + 7] = FLOAT_BYTES[0];\n            return 8;\n        }\n        : (destination, offset, value) => {\n            FLOAT[0] = value;\n            destination[offset] = FLOAT_BYTES[0];\n            destination[offset + 1] = FLOAT_BYTES[1];\n            destination[offset + 2] = FLOAT_BYTES[2];\n            destination[offset + 3] = FLOAT_BYTES[3];\n            destination[offset + 4] = FLOAT_BYTES[4];\n            destination[offset + 5] = FLOAT_BYTES[5];\n            destination[offset + 6] = FLOAT_BYTES[6];\n            destination[offset + 7] = FLOAT_BYTES[7];\n            return 8;\n        }\n};\n\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return 'Binary';\n    }\n    constructor(buffer, subType) {\n        super();\n        if (!(buffer == null) &&\n            typeof buffer === 'string' &&\n            !ArrayBuffer.isView(buffer) &&\n            !isAnyArrayBuffer(buffer) &&\n            !Array.isArray(buffer)) {\n            throw new BSONError('Binary can only be constructed from Uint8Array or number[]');\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        }\n        else {\n            this.buffer = Array.isArray(buffer)\n                ? ByteUtils.fromNumberArray(buffer)\n                : ByteUtils.toLocalBufferType(buffer);\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === 'string' && byteValue.length !== 1) {\n            throw new BSONError('only accepts single character String');\n        }\n        else if (typeof byteValue !== 'number' && byteValue.length !== 1)\n            throw new BSONError('only accepts single character Uint8Array or Array');\n        let decodedByte;\n        if (typeof byteValue === 'string') {\n            decodedByte = byteValue.charCodeAt(0);\n        }\n        else if (typeof byteValue === 'number') {\n            decodedByte = byteValue;\n        }\n        else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        }\n        else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === 'number' ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position =\n                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        }\n        else if (typeof sequence === 'string') {\n            throw new BSONError('input cannot be string');\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        const end = position + length;\n        return this.buffer.subarray(position, end > this.position ? this.position : end);\n    }\n    value() {\n        return this.buffer.length === this.position\n            ? this.buffer\n            : this.buffer.subarray(0, this.position);\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.buffer.subarray(0, this.position));\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        if (encoding === 'utf8' || encoding === 'utf-8')\n            return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (this.sub_type === Binary.SUBTYPE_VECTOR) {\n            validateBinaryVector(this);\n        }\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? '0' + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? '0' + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.subarray(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if ('$binary' in doc) {\n            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            }\n            else {\n                if (typeof doc.$binary !== 'string') {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        }\n        else if ('$uuid' in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        const base64Arg = inspect(base64, options);\n        const subTypeArg = inspect(this.sub_type, options);\n        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n    }\n    toInt8Array() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {\n            throw new BSONError('Binary datatype field is not Int8');\n        }\n        return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n    }\n    toFloat32Array() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {\n            throw new BSONError('Binary datatype field is not Float32');\n        }\n        const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n        if (NumberUtils.isBigEndian)\n            ByteUtils.swap32(floatBytes);\n        return new Float32Array(floatBytes.buffer);\n    }\n    toPackedBits() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n            throw new BSONError('Binary datatype field is not packed bit');\n        }\n        return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n    }\n    toBits() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n            throw new BSONError('Binary datatype field is not packed bit');\n        }\n        const byteCount = this.length() - 2;\n        const bitCount = byteCount * 8 - this.buffer[1];\n        const bits = new Int8Array(bitCount);\n        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n            const byteOffset = (bitOffset / 8) | 0;\n            const byte = this.buffer[byteOffset + 2];\n            const shift = 7 - (bitOffset % 8);\n            const bit = (byte >> shift) & 1;\n            bits[bitOffset] = bit;\n        }\n        return bits;\n    }\n    static fromInt8Array(array) {\n        const buffer = ByteUtils.allocate(array.byteLength + 2);\n        buffer[0] = Binary.VECTOR_TYPE.Int8;\n        buffer[1] = 0;\n        const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        buffer.set(intBytes, 2);\n        return new this(buffer, this.SUBTYPE_VECTOR);\n    }\n    static fromFloat32Array(array) {\n        const binaryBytes = ByteUtils.allocate(array.byteLength + 2);\n        binaryBytes[0] = Binary.VECTOR_TYPE.Float32;\n        binaryBytes[1] = 0;\n        const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        binaryBytes.set(floatBytes, 2);\n        if (NumberUtils.isBigEndian)\n            ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));\n        return new this(binaryBytes, this.SUBTYPE_VECTOR);\n    }\n    static fromPackedBits(array, padding = 0) {\n        const buffer = ByteUtils.allocate(array.byteLength + 2);\n        buffer[0] = Binary.VECTOR_TYPE.PackedBit;\n        buffer[1] = padding;\n        buffer.set(array, 2);\n        return new this(buffer, this.SUBTYPE_VECTOR);\n    }\n    static fromBits(bits) {\n        const byteLength = (bits.length + 7) >>> 3;\n        const bytes = new Uint8Array(byteLength + 2);\n        bytes[0] = Binary.VECTOR_TYPE.PackedBit;\n        const remainder = bits.length % 8;\n        bytes[1] = remainder === 0 ? 0 : 8 - remainder;\n        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n            const byteOffset = bitOffset >>> 3;\n            const bit = bits[bitOffset];\n            if (bit !== 0 && bit !== 1) {\n                throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);\n            }\n            if (bit === 0)\n                continue;\n            const shift = 7 - (bitOffset % 8);\n            bytes[byteOffset + 2] |= bit << shift;\n        }\n        return new this(bytes, Binary.SUBTYPE_VECTOR);\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_SENSITIVE = 8;\nBinary.SUBTYPE_VECTOR = 9;\nBinary.SUBTYPE_USER_DEFINED = 128;\nBinary.VECTOR_TYPE = Object.freeze({\n    Int8: 0x03,\n    Float32: 0x27,\n    PackedBit: 0x10\n});\nfunction validateBinaryVector(vector) {\n    if (vector.sub_type !== Binary.SUBTYPE_VECTOR)\n        return;\n    const size = vector.position;\n    const datatype = vector.buffer[0];\n    const padding = vector.buffer[1];\n    if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) &&\n        padding !== 0) {\n        throw new BSONError('Invalid Vector: padding must be zero for int8 and float32 vectors');\n    }\n    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {\n        throw new BSONError('Invalid Vector: padding must be zero for packed bit vectors that are empty');\n    }\n    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {\n        throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);\n    }\n}\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input) {\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        }\n        else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        }\n        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        }\n        else if (typeof input === 'string') {\n            bytes = UUID.bytesFromString(input);\n        }\n        else {\n            throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join('-');\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.id);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        }\n        catch {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = (bytes[6] & 0x0f) | 0x40;\n        bytes[8] = (bytes[8] & 0x3f) | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === 'string') {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return (input._bsontype === 'Binary' &&\n            input.sub_type === this.SUBTYPE_UUID &&\n            input.buffer.byteLength === 16);\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, ''));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new UUID(${inspect(this.toHexString(), options)})`;\n    }\n}\n\nclass Code extends BSONValue {\n    get _bsontype() {\n        return 'Code';\n    }\n    constructor(code, scope) {\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return { code: this.code, scope: this.scope };\n        }\n        return { code: this.code };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return { $code: this.code, $scope: this.scope };\n        }\n        return { $code: this.code };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        let parametersString = inspect(this.code, options);\n        const multiLineFn = parametersString.includes('\\n');\n        if (this.scope != null) {\n            parametersString += `,${multiLineFn ? '\\n' : ' '}${inspect(this.scope, options)}`;\n        }\n        const endingNewline = multiLineFn && this.scope === null;\n        return `new Code(${multiLineFn ? '\\n' : ''}${parametersString}${endingNewline ? '\\n' : ''})`;\n    }\n}\n\nfunction isDBRefLike(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '$id' in value &&\n        value.$id != null &&\n        '$ref' in value &&\n        typeof value.$ref === 'string' &&\n        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return 'DBRef';\n    }\n    constructor(collection, oid, db, fields) {\n        super();\n        const parts = collection.split('.');\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null)\n            o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db)\n            o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const args = [\n            inspect(this.namespace, options),\n            inspect(this.oid, options),\n            ...(this.db ? [inspect(this.db, options)] : []),\n            ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : [])\n        ];\n        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n        return `new DBRef(${args.join(', ')})`;\n    }\n}\n\nfunction removeLeadingZerosAndExplicitPlus(str) {\n    if (str === '') {\n        return str;\n    }\n    let startIndex = 0;\n    const isNegative = str[startIndex] === '-';\n    const isExplicitlyPositive = str[startIndex] === '+';\n    if (isExplicitlyPositive || isNegative) {\n        startIndex += 1;\n    }\n    let foundInsignificantZero = false;\n    for (; startIndex < str.length && str[startIndex] === '0'; ++startIndex) {\n        foundInsignificantZero = true;\n    }\n    if (!foundInsignificantZero) {\n        return isExplicitlyPositive ? str.slice(1) : str;\n    }\n    return `${isNegative ? '-' : ''}${str.length === startIndex ? '0' : str.slice(startIndex)}`;\n}\nfunction validateStringCharacters(str, radix) {\n    radix = radix ?? 10;\n    const validCharacters = '0123456789abcdefghijklmnopqrstuvwxyz'.slice(0, radix);\n    const regex = new RegExp(`[^-+${validCharacters}]`, 'i');\n    return regex.test(str) ? false : str;\n}\n\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n}\ncatch {\n}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return 'Long';\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {\n        super();\n        const unsignedBool = typeof highOrUnsigned === 'boolean' ? highOrUnsigned : Boolean(unsigned);\n        const high = typeof highOrUnsigned === 'number' ? highOrUnsigned : 0;\n        const res = typeof lowOrValue === 'string'\n            ? Long.fromString(lowOrValue, unsignedBool)\n            : typeof lowOrValue === 'bigint'\n                ? Long.fromBigInt(lowOrValue, unsignedBool)\n                : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };\n        this.low = res.low;\n        this.high = res.high;\n        this.unsigned = res.unsigned;\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if ((cache = 0 <= value && value < 256)) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache)\n                UINT_CACHE[value] = obj;\n            return obj;\n        }\n        else {\n            value |= 0;\n            if ((cache = -128 <= value && value < 128)) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache)\n                INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value))\n            return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0)\n                return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL)\n                return Long.MAX_UNSIGNED_VALUE;\n        }\n        else {\n            if (value <= -TWO_PWR_63_DBL)\n                return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL)\n                return Long.MAX_VALUE;\n        }\n        if (value < 0)\n            return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        const FROM_BIGINT_BIT_MASK = BigInt(0xffffffff);\n        const FROM_BIGINT_BIT_SHIFT = BigInt(32);\n        return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number((value >> FROM_BIGINT_BIT_SHIFT) & FROM_BIGINT_BIT_MASK), unsigned);\n    }\n    static _fromString(str, unsigned, radix) {\n        if (str.length === 0)\n            throw new BSONError('empty string');\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        let p;\n        if ((p = str.indexOf('-')) > 0)\n            throw new BSONError('interior hyphen');\n        else if (p === 0) {\n            return Long._fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for (let i = 0; i < str.length; i += 8) {\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            }\n            else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromStringStrict(str, unsignedOrRadix, radix) {\n        let unsigned = false;\n        if (typeof unsignedOrRadix === 'number') {\n            (radix = unsignedOrRadix), (unsignedOrRadix = false);\n        }\n        else {\n            unsigned = !!unsignedOrRadix;\n        }\n        radix ??= 10;\n        if (str.trim() !== str) {\n            throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);\n        }\n        if (!validateStringCharacters(str, radix)) {\n            throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);\n        }\n        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);\n        const result = Long._fromString(cleanedStr, unsigned, radix);\n        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {\n            throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? 'an unsigned' : 'a signed'} 64-bit Long ${radix != null ? `with radix: ${radix}` : ''}`);\n        }\n        return result;\n    }\n    static fromString(str, unsignedOrRadix, radix) {\n        let unsigned = false;\n        if (typeof unsignedOrRadix === 'number') {\n            (radix = unsignedOrRadix), (unsignedOrRadix = false);\n        }\n        else {\n            unsigned = !!unsignedOrRadix;\n        }\n        radix ??= 10;\n        if (str === 'NaN' && radix < 24) {\n            return Long.ZERO;\n        }\n        else if ((str === 'Infinity' || str === '+Infinity' || str === '-Infinity') && radix < 35) {\n            return Long.ZERO;\n        }\n        return Long._fromString(str, unsigned, radix);\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            '__isLong__' in value &&\n            value.__isLong__ === true);\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === 'number')\n            return Long.fromNumber(val, unsigned);\n        if (typeof val === 'string')\n            return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend))\n            addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.eq(other))\n            return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg)\n            return -1;\n        if (!thisNeg && otherNeg)\n            return 1;\n        if (!this.unsigned)\n            return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 ||\n            (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n            ? -1\n            : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (divisor.isZero())\n            throw new BSONError('division by zero');\n        if (wasm) {\n            if (!this.unsigned &&\n                this.high === -0x80000000 &&\n                divisor.low === -1 &&\n                divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero())\n            return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))\n                    return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE))\n                    return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    }\n                    else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            }\n            else if (divisor.eq(Long.MIN_VALUE))\n                return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative())\n                    return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            }\n            else if (divisor.isNegative())\n                return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        }\n        else {\n            if (!divisor.unsigned)\n                divisor = divisor.toUnsigned();\n            if (divisor.gt(this))\n                return Long.UZERO;\n            if (divisor.gt(this.shru(1)))\n                return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while (rem.gte(divisor)) {\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero())\n                approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n            return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for (bit = 31; bit > 0; bit--)\n            if ((val & (1 << bit)) !== 0)\n                break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero())\n            return Long.ZERO;\n        if (!Long.isLong(multiplier))\n            multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero())\n            return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE))\n            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE))\n            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative())\n                return this.neg().mul(multiplier.neg());\n            else\n                return this.neg().mul(multiplier).neg();\n        }\n        else if (multiplier.isNegative())\n            return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))\n            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE))\n            return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n        else\n            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n        else\n            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0)\n            return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\n            }\n            else if (numBits === 32)\n                return Long.fromBits(high, 0, this.unsigned);\n            else\n                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend))\n            subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned)\n            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            (lo >>> 8) & 0xff,\n            (lo >>> 16) & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            (hi >>> 8) & 0xff,\n            (hi >>> 16) & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            (hi >>> 16) & 0xff,\n            (hi >>> 8) & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            (lo >>> 16) & 0xff,\n            (lo >>> 8) & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        if (this.isZero())\n            return '0';\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            }\n            else\n                return '-' + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = '';\n        while (true) {\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            }\n            else {\n                while (digits.length < 6)\n                    digits = '0' + digits;\n                result = '' + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed)\n            return this.toNumber();\n        return { $numberLong: this.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = { ...options };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError('$numberLong string is too long');\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const longVal = inspect(this.toString(), options);\n        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : '';\n        return `new Long(${longVal}${unsignedVal})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return { quotient: value, rem: _rem };\n    }\n    for (let i = 0; i <= 3; i++) {\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0)\n        .add(productMid2)\n        .add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    }\n    else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright)\n            return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return 'Decimal128';\n    }\n    constructor(bytes) {\n        super();\n        if (typeof bytes === 'string') {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        }\n        else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError('Decimal128 must take a Buffer of 16 bytes');\n            }\n            this.bytes = bytes;\n        }\n        else {\n            throw new BSONError('Decimal128 must take a Buffer or string');\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, { allowRounding: false });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, { allowRounding: true });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [0];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined)\n                invalidErr(representation, 'missing exponent power');\n            if (e && unsignedNumber === undefined)\n                invalidErr(representation, 'missing exponent base');\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, 'missing e before exponent');\n            }\n        }\n        if (representation[index] === '+' || representation[index] === '-') {\n            sawSign = true;\n            isNegative = representation[index++] === '-';\n        }\n        if (!isDigit(representation[index]) && representation[index] !== '.') {\n            if (representation[index] === 'i' || representation[index] === 'I') {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            }\n            else if (representation[index] === 'N') {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while (isDigit(representation[index]) || representation[index] === '.') {\n            if (representation[index] === '.') {\n                if (sawRadix)\n                    invalidErr(representation, 'contains multiple periods');\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== '0' || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero)\n                nDigits = nDigits + 1;\n            if (sawRadix)\n                radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead)\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        if (representation[index] === 'e' || representation[index] === 'E') {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2])\n                return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index])\n            return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        }\n        else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') {\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        }\n        else {\n            exponent = exponent - radixPosition;\n        }\n        while (exponent > EXPONENT_MAX) {\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, 'overflow');\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    const digitsString = digits.join('');\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for (; dIdx >= 0; dIdx--) {\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                }\n                                else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, 'exponent underflow');\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' &&\n                        significantDigits !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, 'inexact rounding');\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        }\n        else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit - 17; dIdx++) {\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        }\n        else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString('9223372036854775808'));\n        }\n        const buffer = ByteUtils.allocateUnsafe(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = (dec.low.low >> 8) & 0xff;\n        buffer[index++] = (dec.low.low >> 16) & 0xff;\n        buffer[index++] = (dec.low.low >> 24) & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = (dec.low.high >> 8) & 0xff;\n        buffer[index++] = (dec.low.high >> 16) & 0xff;\n        buffer[index++] = (dec.low.high >> 24) & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = (dec.high.low >> 8) & 0xff;\n        buffer[index++] = (dec.high.low >> 16) & 0xff;\n        buffer[index++] = (dec.high.low >> 24) & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = (dec.high.high >> 8) & 0xff;\n        buffer[index++] = (dec.high.high >> 16) & 0xff;\n        buffer[index++] = (dec.high.high >> 24) & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for (let i = 0; i < significand.length; i++)\n            significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = { parts: [0, 0, 0, 0] };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push('-');\n        }\n        const combination = (high >> 26) & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join('') + 'Infinity';\n            }\n            else if (combination === COMBINATION_NAN) {\n                return 'NaN';\n            }\n            else {\n                biased_exponent = (high >> 15) & EXPONENT_MASK;\n                significand_msb = 0x08 + ((high >> 14) & 0x01);\n            }\n        }\n        else {\n            significand_msb = (high >> 14) & 0x07;\n            biased_exponent = (high >> 17) & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 &&\n            significand128.parts[1] === 0 &&\n            significand128.parts[2] === 0 &&\n            significand128.parts[3] === 0) {\n            is_zero = true;\n        }\n        else {\n            for (k = 3; k >= 0; k--) {\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits)\n                    continue;\n                for (j = 8; j >= 0; j--) {\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        }\n        else {\n            significand_digits = 36;\n            while (!significand[index]) {\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0)\n                    string.push(`E+${exponent}`);\n                else if (exponent < 0)\n                    string.push(`E${exponent}`);\n                return string.join('');\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push('.');\n            }\n            for (let i = 0; i < significand_digits; i++) {\n                string.push(`${significand[index++]}`);\n            }\n            string.push('E');\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            }\n            else {\n                string.push(`${scientific_exponent}`);\n            }\n        }\n        else {\n            if (exponent >= 0) {\n                for (let i = 0; i < significand_digits; i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n            else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for (let i = 0; i < radix_position; i++) {\n                        string.push(`${significand[index++]}`);\n                    }\n                }\n                else {\n                    string.push('0');\n                }\n                string.push('.');\n                while (radix_position++ < 0) {\n                    string.push('0');\n                }\n                for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join('');\n    }\n    toJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    toExtendedJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const d128string = inspect(this.toString(), options);\n        return `new Decimal128(${d128string})`;\n    }\n}\n\nclass Double extends BSONValue {\n    get _bsontype() {\n        return 'Double';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    static fromString(value) {\n        const coercedValue = Number(value);\n        if (value === 'NaN')\n            return new Double(NaN);\n        if (value === 'Infinity')\n            return new Double(Infinity);\n        if (value === '-Infinity')\n            return new Double(-Infinity);\n        if (!Number.isFinite(coercedValue)) {\n            throw new BSONError(`Input: ${value} is not representable as a Double`);\n        }\n        if (value.trim() !== value) {\n            throw new BSONError(`Input: '${value}' contains whitespace`);\n        }\n        if (value === '') {\n            throw new BSONError(`Input is an empty string`);\n        }\n        if (/[^-0-9.+eE]/.test(value)) {\n            throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);\n        }\n        return new Double(coercedValue);\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return { $numberDouble: '-0.0' };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Double(${inspect(this.value, options)})`;\n    }\n}\n\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return 'Int32';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    static fromString(value) {\n        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);\n        const coercedValue = Number(value);\n        if (BSON_INT32_MAX < coercedValue) {\n            throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);\n        }\n        else if (BSON_INT32_MIN > coercedValue) {\n            throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);\n        }\n        else if (!Number.isSafeInteger(coercedValue)) {\n            throw new BSONError(`Input: '${value}' is not a safe integer`);\n        }\n        else if (coercedValue.toString() !== cleanedValue) {\n            throw new BSONError(`Input: '${value}' is not a valid Int32 string`);\n        }\n        return new Int32(coercedValue);\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy))\n            return this.value;\n        return { $numberInt: this.value.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Int32(${inspect(this.value, options)})`;\n    }\n}\n\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return 'MaxKey';\n    }\n    toExtendedJSON() {\n        return { $maxKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    inspect() {\n        return 'new MaxKey()';\n    }\n}\n\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return 'MinKey';\n    }\n    toExtendedJSON() {\n        return { $minKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    inspect() {\n        return 'new MinKey()';\n    }\n}\n\nlet PROCESS_UNIQUE = null;\nconst __idCache = new WeakMap();\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return 'ObjectId';\n    }\n    constructor(inputId) {\n        super();\n        let workingId;\n        if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n            }\n            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            }\n            else {\n                workingId = inputId.id;\n            }\n        }\n        else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === 'number') {\n            this.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n        }\n        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this.buffer = ByteUtils.toLocalBufferType(workingId);\n        }\n        else if (typeof workingId === 'string') {\n            if (ObjectId.validateHexString(workingId)) {\n                this.buffer = ByteUtils.fromHex(workingId);\n                if (ObjectId.cacheHexString) {\n                    __idCache.set(this, workingId);\n                }\n            }\n            else {\n                throw new BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer');\n            }\n        }\n        else {\n            throw new BSONError('Argument passed in does not match the accepted types');\n        }\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n        if (ObjectId.cacheHexString) {\n            __idCache.set(this, ByteUtils.toHex(value));\n        }\n    }\n    static validateHexString(string) {\n        if (string?.length !== 24)\n            return false;\n        for (let i = 0; i < 24; i++) {\n            const char = string.charCodeAt(i);\n            if ((char >= 48 && char <= 57) ||\n                (char >= 97 && char <= 102) ||\n                (char >= 65 && char <= 70)) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString) {\n            const __id = __idCache.get(this);\n            if (__id)\n                return __id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString) {\n            __idCache.set(this, hexString);\n        }\n        return hexString;\n    }\n    static getInc() {\n        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\n    }\n    static generate(time) {\n        if ('number' !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocateUnsafe(12);\n        NumberUtils.setInt32BE(buffer, 0, time);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = (inc >> 8) & 0xff;\n        buffer[9] = (inc >> 16) & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        if (encoding === 'hex')\n            return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    static is(variable) {\n        return (variable != null &&\n            typeof variable === 'object' &&\n            '_bsontype' in variable &&\n            variable._bsontype === 'ObjectId');\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (ObjectId.is(otherId)) {\n            return (this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer));\n        }\n        if (typeof otherId === 'string') {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString();\n            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = NumberUtils.getUint32BE(this.buffer, 0);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    serializeInto(uint8array, index) {\n        uint8array[index] = this.buffer[0];\n        uint8array[index + 1] = this.buffer[1];\n        uint8array[index + 2] = this.buffer[2];\n        uint8array[index + 3] = this.buffer[3];\n        uint8array[index + 4] = this.buffer[4];\n        uint8array[index + 5] = this.buffer[5];\n        uint8array[index + 6] = this.buffer[6];\n        uint8array[index + 7] = this.buffer[7];\n        uint8array[index + 8] = this.buffer[8];\n        uint8array[index + 9] = this.buffer[9];\n        uint8array[index + 10] = this.buffer[10];\n        uint8array[index + 11] = this.buffer[11];\n        return 12;\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.allocate(12);\n        for (let i = 11; i >= 4; i--)\n            buffer[i] = 0;\n        NumberUtils.setInt32BE(buffer, 0, time);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError('hex string must be 24 characters');\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError('base64 string must be 16 characters');\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null)\n            return false;\n        if (typeof id === 'string')\n            return ObjectId.validateHexString(id);\n        try {\n            new ObjectId(id);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString)\n            return { $oid: this.toHexString() };\n        return { $oid: this.toString('hex') };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    isCached() {\n        return ObjectId.cacheHexString && __idCache.has(this);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new ObjectId(${inspect(this.toHexString(), options)})`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\n\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)) {\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n    }\n    switch (typeof value) {\n        case 'string':\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case 'number':\n            if (Math.floor(value) === value &&\n                value >= JS_INT_MIN &&\n                value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                }\n                else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            }\n            else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case 'undefined':\n            if (isArray || !ignoreUndefined)\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case 'boolean':\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case 'object':\n            if (value != null &&\n                typeof value._bsontype === 'string' &&\n                value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            }\n            else if (value._bsontype === 'ObjectId') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (ArrayBuffer.isView(value) ||\n                value instanceof ArrayBuffer ||\n                isAnyArrayBuffer(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength);\n            }\n            else if (value._bsontype === 'Long' ||\n                value._bsontype === 'Double' ||\n                value._bsontype === 'Timestamp') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            }\n            else if (value._bsontype === 'Code') {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1 +\n                        internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1);\n                }\n            }\n            else if (value._bsontype === 'Binary') {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        (binary.position + 1 + 4 + 1 + 4));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1));\n                }\n            }\n            else if (value._bsontype === 'Symbol') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    ByteUtils.utf8ByteLength(value.value) +\n                    4 +\n                    1 +\n                    1);\n            }\n            else if (value._bsontype === 'DBRef') {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values['$db'] = value.db;\n                }\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined));\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.source) +\n                    1 +\n                    (value.global ? 1 : 0) +\n                    (value.ignoreCase ? 1 : 0) +\n                    (value.multiline ? 1 : 0) +\n                    1);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.pattern) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.options) +\n                    1);\n            }\n            else {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) +\n                    1);\n            }\n        case 'function':\n            if (serializeFunctions) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    4 +\n                    ByteUtils.utf8ByteLength(value.toString()) +\n                    1);\n            }\n    }\n    return 0;\n}\n\nfunction alphabetize(str) {\n    return str.split('').sort().join('');\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return 'BSONRegExp';\n    }\n    constructor(pattern, options) {\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? '');\n        if (this.pattern.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for (let i = 0; i < this.options.length; i++) {\n            if (!(this.options[i] === 'i' ||\n                this.options[i] === 'm' ||\n                this.options[i] === 'x' ||\n                this.options[i] === 'l' ||\n                this.options[i] === 's' ||\n                this.options[i] === 'u')) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split('').sort().join('') : '';\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return { $regex: this.pattern, $options: this.options };\n        }\n        return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    }\n    static fromExtendedJSON(doc) {\n        if ('$regex' in doc) {\n            if (typeof doc.$regex !== 'string') {\n                if (doc.$regex._bsontype === 'BSONRegExp') {\n                    return doc;\n                }\n            }\n            else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if ('$regularExpression' in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    inspect(depth, options, inspect) {\n        const stylize = getStylizeFunction(options) ?? (v => v);\n        inspect ??= defaultInspect;\n        const pattern = stylize(inspect(this.pattern), 'regexp');\n        const flags = stylize(inspect(this.options), 'regexp');\n        return `new BSONRegExp(${pattern}, ${flags})`;\n    }\n}\n\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return 'BSONSymbol';\n    }\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return { $symbol: this.value };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new BSONSymbol(${inspect(this.value, options)})`;\n    }\n}\n\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return 'Timestamp';\n    }\n    get i() {\n        return this.low >>> 0;\n    }\n    get t() {\n        return this.high >>> 0;\n    }\n    constructor(low) {\n        if (low == null) {\n            super(0, 0, true);\n        }\n        else if (typeof low === 'bigint') {\n            super(low, true);\n        }\n        else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        }\n        else if (typeof low === 'object' && 't' in low && 'i' in low) {\n            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');\n            }\n            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');\n            }\n            if (t > 0xffff_ffff) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');\n            }\n            if (i > 0xffff_ffff) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');\n            }\n            super(i, t, true);\n        }\n        else {\n            throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({ i: lowBits, t: highBits });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return { $timestamp: { t: this.t, i: this.i } };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i)\n            ? doc.$timestamp.i.getLowBitsUnsigned()\n            : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t)\n            ? doc.$timestamp.t.getLowBitsUnsigned()\n            : doc.$timestamp.t;\n        return new Timestamp({ t, i });\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const t = inspect(this.t, options);\n        const i = inspect(this.i, options);\n        return `new Timestamp({ t: ${t}, i: ${i} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = NumberUtils.getInt32LE(buffer, index);\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n    const raw = options['raw'] == null ? false : options['raw'];\n    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    const validation = options.validation == null ? { utf8: true } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    let utf8KeysSet;\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === 'boolean') {\n        validationSetting = utf8ValidatedKeys;\n    }\n    else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError('UTF-8 validation setting cannot be empty');\n        }\n        if (typeof utf8ValidationValues[0] !== 'boolean') {\n            throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every(item => item === validationSetting)) {\n            throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n        }\n    }\n    if (!globalUTFValidation) {\n        utf8KeysSet = new Set();\n        for (const key of Object.keys(utf8ValidatedKeys)) {\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5)\n        throw new BSONError('corrupt bson message < 5 bytes long');\n    const size = NumberUtils.getInt32LE(buffer, index);\n    index += 4;\n    if (size < 5 || size > buffer.length)\n        throw new BSONError('corrupt bson message');\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    while (!done) {\n        const elementType = buffer[index++];\n        if (elementType === 0)\n            break;\n        let i = index;\n        while (buffer[i] !== 0x00 && i < buffer.length) {\n            i++;\n        }\n        if (i >= buffer.byteLength)\n            throw new BSONError('Bad BSON Document: illegal CString');\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet?.has(name)) {\n            shouldValidateKey = validationSetting;\n        }\n        else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === '$') {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocateUnsafe(12);\n            for (let i = 0; i < 12; i++)\n                oid[i] = buffer[index + i];\n            value = new ObjectId(oid);\n            index = index + 12;\n        }\n        else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(NumberUtils.getInt32LE(buffer, index));\n            index += 4;\n        }\n        else if (elementType === BSON_DATA_INT) {\n            value = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n        }\n        else if (elementType === BSON_DATA_NUMBER) {\n            value = NumberUtils.getFloat64LE(buffer, index);\n            index += 8;\n            if (promoteValues === false)\n                value = new Double(value);\n        }\n        else if (elementType === BSON_DATA_DATE) {\n            const lowBits = NumberUtils.getInt32LE(buffer, index);\n            const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n            index += 8;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        }\n        else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1)\n                throw new BSONError('illegal boolean type value');\n            value = buffer[index++] === 1;\n        }\n        else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            if (objectSize <= 0 || objectSize > buffer.length - index)\n                throw new BSONError('bad embedded document length in bson');\n            if (raw) {\n                value = buffer.subarray(index, index + objectSize);\n            }\n            else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        }\n        else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = { ...options, raw: true };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0)\n                throw new BSONError('invalid array terminator byte');\n            if (index !== stopIndex)\n                throw new BSONError('corrupted array bson');\n        }\n        else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        }\n        else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        }\n        else if (elementType === BSON_DATA_LONG) {\n            if (useBigInt64) {\n                value = NumberUtils.getBigInt64LE(buffer, index);\n                index += 8;\n            }\n            else {\n                const lowBits = NumberUtils.getInt32LE(buffer, index);\n                const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n                index += 8;\n                const long = new Long(lowBits, highBits);\n                if (promoteLongs && promoteValues === true) {\n                    value =\n                        long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n                            ? long.toNumber()\n                            : long;\n                }\n                else {\n                    value = long;\n                }\n            }\n        }\n        else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocateUnsafe(16);\n            for (let i = 0; i < 16; i++)\n                bytes[i] = buffer[index + i];\n            index = index + 16;\n            value = new Decimal128(bytes);\n        }\n        else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0)\n                throw new BSONError('Negative binary type element size found');\n            if (binarySize > buffer.byteLength)\n                throw new BSONError('Binary type size larger than document size');\n            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                binarySize = NumberUtils.getInt32LE(buffer, index);\n                index += 4;\n                if (binarySize < 0)\n                    throw new BSONError('Negative binary type element size found for subtype 0x02');\n                if (binarySize > totalBinarySize - 4)\n                    throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                if (binarySize < totalBinarySize - 4)\n                    throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n            }\n            if (promoteBuffers && promoteValues) {\n                value = ByteUtils.toLocalBufferType(buffer.subarray(index, index + binarySize));\n            }\n            else {\n                value = new Binary(buffer.subarray(index, index + binarySize), subType);\n                if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                    value = value.toUUID();\n                }\n            }\n            index = index + binarySize;\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for (i = 0; i < regExpOptions.length; i++) {\n                switch (regExpOptions[i]) {\n                    case 'm':\n                        optionsArray[i] = 'm';\n                        break;\n                    case 's':\n                        optionsArray[i] = 'g';\n                        break;\n                    case 'i':\n                        optionsArray[i] = 'i';\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(''));\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        }\n        else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_TIMESTAMP) {\n            value = new Timestamp({\n                i: NumberUtils.getUint32LE(buffer, index),\n                t: NumberUtils.getUint32LE(buffer, index + 4)\n            });\n            index += 8;\n        }\n        else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        }\n        else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        }\n        else if (elementType === BSON_DATA_CODE) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError('code_w_scope total size shorter minimum expected length');\n            }\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too short, truncating scope');\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too long, clips outer document');\n            }\n            value = new Code(functionString, scopeObject);\n        }\n        else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0)\n                throw new BSONError('bad string length in bson');\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocateUnsafe(12);\n            for (let i = 0; i < 12; i++)\n                oidBuffer[i] = buffer[index + i];\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        }\n        else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === '__proto__') {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray)\n            throw new BSONError('corrupt array bson');\n        throw new BSONError('corrupt object bson');\n    }\n    if (!isPossibleDBRef)\n        return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\n\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    NumberUtils.setInt32LE(buffer, index, size + 1);\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero &&\n        Number.isSafeInteger(value) &&\n        value <= BSON_INT32_MAX &&\n        value >= BSON_INT32_MIN\n        ? BSON_DATA_INT\n        : BSON_DATA_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    if (type === BSON_DATA_INT) {\n        index += NumberUtils.setInt32LE(buffer, index, value);\n    }\n    else {\n        index += NumberUtils.setFloat64LE(buffer, index, value);\n    }\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setBigInt64LE(buffer, index, value);\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError('value ' + value.source + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase)\n        buffer[index++] = 0x69;\n    if (value.global)\n        buffer[index++] = 0x73;\n    if (value.multiline)\n        buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split('').sort().join('');\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    }\n    else if (value._bsontype === 'MinKey') {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    }\n    else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += value.serializeInto(buffer, index);\n    return index;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    if (size <= 16) {\n        for (let i = 0; i < size; i++)\n            buffer[index + i] = value[i];\n    }\n    else {\n        buffer.set(value, index);\n    }\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError('Cannot convert circular structure to BSON');\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    for (let i = 0; i < 16; i++)\n        buffer[index + i] = value.bytes[i];\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] =\n        value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setInt32LE(buffer, index, value);\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setFloat64LE(buffer, index, value.value);\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === 'object') {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, codeSize);\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);\n        buffer[index++] = 0;\n    }\n    else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, size);\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n        size = size + 4;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        index += NumberUtils.setInt32LE(buffer, index, size);\n    }\n    if (value.sub_type === Binary.SUBTYPE_VECTOR) {\n        validateBinaryVector(value);\n    }\n    if (size <= 16) {\n        for (let i = 0; i < size; i++)\n            buffer[index + i] = data[i];\n    }\n    else {\n        buffer.set(data, index);\n    }\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    startIndex += NumberUtils.setInt32LE(buffer, index, size);\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError('serialize does not support an array as the root input');\n        }\n        if (typeof object !== 'object') {\n            throw new BSONError('serialize does not support non-object as the root input');\n        }\n        else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        }\n        else if (isDate(object) ||\n            isRegExp(object) ||\n            isUint8Array(object) ||\n            isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while (!done) {\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done)\n                continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (key.includes('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n            if (object != null && typeof object !== 'object') {\n                throw new BSONError('toBSON function did not return an object');\n            }\n        }\n        for (const key of Object.keys(object)) {\n            let value = object[key];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (key.includes('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);\n    return index;\n}\n\nfunction isBSONType(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '_bsontype' in value &&\n        typeof value._bsontype === 'string');\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === 'number') {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== 'object')\n        return value;\n    if (value.$undefined)\n        return null;\n    const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);\n    for (let i = 0; i < keys.length; i++) {\n        const c = keysToCodecs[keys[i]];\n        if (c)\n            return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === 'number')\n                date.setTime(d);\n            else if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        else {\n            if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (Long.isLong(d))\n                date.setTime(d.toNumber());\n            else if (typeof d === 'number' && options.relaxed)\n                date.setTime(d);\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef)\n            return v;\n        const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\n        let valid = true;\n        dollarKeys.forEach(k => {\n            if (['$ref', '$id', '$db'].indexOf(k) === -1)\n                valid = false;\n        });\n        if (valid)\n            return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index) => {\n        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });\n        try {\n            return serializeValue(v, options);\n        }\n        finally {\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value) {\n            if (typeof k !== 'string') {\n                throw new BSONError('Can only serialize maps with string keys');\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n        const index = options.seenObjects.findIndex(entry => entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map(entry => entry.propertyName);\n            const leadingPart = props\n                .slice(0, index)\n                .map(prop => `${prop} -> `)\n                .join('');\n            const alreadySeen = props[index];\n            const circularPart = ' -> ' +\n                props\n                    .slice(index + 1, props.length - 1)\n                    .map(prop => `${prop} -> `)\n                    .join('');\n            const current = props[props.length - 1];\n            const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError('Converting circular structure to EJSON:\\n' +\n                `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` +\n                `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value))\n        return serializeArray(value, options);\n    if (value === undefined)\n        return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange\n                ? { $date: value.getTime() }\n                : { $date: getISOString(value) };\n        }\n        return options.relaxed && inRange\n            ? { $date: getISOString(value) }\n            : { $date: { $numberLong: value.getTime().toString() } };\n    }\n    if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return { $numberInt: value.toString() };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return { $numberLong: value.toString() };\n            }\n        }\n        return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() };\n    }\n    if (typeof value === 'bigint') {\n        if (!options.relaxed) {\n            return { $numberLong: BigInt.asIntN(64, value).toString() };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === 'object')\n        return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o) => new Binary(o.value(), o.sub_type),\n    Code: (o) => new Code(o.code, o.scope),\n    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o) => new Decimal128(o.bytes),\n    Double: (o) => new Double(o.value),\n    Int32: (o) => new Int32(o.value),\n    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: () => new MaxKey(),\n    MinKey: () => new MinKey(),\n    ObjectId: (o) => new ObjectId(o),\n    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o) => new BSONSymbol(o.value),\n    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== 'object')\n        throw new BSONError('not an object instance');\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === 'undefined') {\n        const _doc = {};\n        for (const name of Object.keys(doc)) {\n            options.seenObjects.push({ propertyName: name, obj: null });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === '__proto__') {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                else {\n                    _doc[name] = value;\n                }\n            }\n            finally {\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    }\n    else if (doc != null &&\n        typeof doc === 'object' &&\n        typeof doc._bsontype === 'string' &&\n        doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    }\n    else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== 'function') {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === 'Code' && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        }\n        else if (bsontype === 'DBRef' && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    }\n    else {\n        throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value) => {\n        if (key.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === 'object') {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n        seenObjects: [{ propertyName: '(root)', obj: null }]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\n\nfunction getSize(source, offset) {\n    try {\n        return NumberUtils.getNonnegativeInt32LE(source, offset);\n    }\n    catch (cause) {\n        throw new BSONOffsetError('BSON size cannot be negative', offset, { cause });\n    }\n}\nfunction findNull(bytes, offset) {\n    let nullTerminatorOffset = offset;\n    for (; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++)\n        ;\n    if (nullTerminatorOffset === bytes.length - 1) {\n        throw new BSONOffsetError('Null terminator not found', offset);\n    }\n    return nullTerminatorOffset;\n}\nfunction parseToElements(bytes, startOffset = 0) {\n    startOffset ??= 0;\n    if (bytes.length < 5) {\n        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);\n    }\n    const documentSize = getSize(bytes, startOffset);\n    if (documentSize > bytes.length - startOffset) {\n        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);\n    }\n    if (bytes[startOffset + documentSize - 1] !== 0x00) {\n        throw new BSONOffsetError('BSON documents must end in 0x00', startOffset + documentSize);\n    }\n    const elements = [];\n    let offset = startOffset + 4;\n    while (offset <= documentSize + startOffset) {\n        const type = bytes[offset];\n        offset += 1;\n        if (type === 0) {\n            if (offset - startOffset !== documentSize) {\n                throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);\n            }\n            break;\n        }\n        const nameOffset = offset;\n        const nameLength = findNull(bytes, offset) - nameOffset;\n        offset += nameLength + 1;\n        let length;\n        if (type === 1 ||\n            type === 18 ||\n            type === 9 ||\n            type === 17) {\n            length = 8;\n        }\n        else if (type === 16) {\n            length = 4;\n        }\n        else if (type === 7) {\n            length = 12;\n        }\n        else if (type === 19) {\n            length = 16;\n        }\n        else if (type === 8) {\n            length = 1;\n        }\n        else if (type === 10 ||\n            type === 6 ||\n            type === 127 ||\n            type === 255) {\n            length = 0;\n        }\n        else if (type === 11) {\n            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;\n        }\n        else if (type === 3 ||\n            type === 4 ||\n            type === 15) {\n            length = getSize(bytes, offset);\n        }\n        else if (type === 2 ||\n            type === 5 ||\n            type === 12 ||\n            type === 13 ||\n            type === 14) {\n            length = getSize(bytes, offset) + 4;\n            if (type === 5) {\n                length += 1;\n            }\n            if (type === 12) {\n                length += 12;\n            }\n        }\n        else {\n            throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, '0')} type byte`, offset);\n        }\n        if (length > documentSize) {\n            throw new BSONOffsetError('value reports length larger than document', offset);\n        }\n        elements.push([type, nameOffset, nameLength, offset, length]);\n        offset += length;\n    }\n    return elements;\n}\n\nconst onDemand = Object.create(null);\nonDemand.parseToElements = parseToElements;\nonDemand.ByteUtils = ByteUtils;\nonDemand.NumberUtils = NumberUtils;\nObject.freeze(onDemand);\n\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === 'number' ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for (let i = 0; i < numberOfDocuments; i++) {\n        const size = NumberUtils.getInt32LE(bufferData, index);\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\n\nvar bson = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONOffsetError: BSONOffsetError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    onDemand: onDemand,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\n\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONOffsetError = BSONOffsetError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.onDemand = onDemand;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize;\n//# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jzb25ANi4xMC4xL25vZGVfbW9kdWxlcy9ic29uL2xpYi9ic29uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxtQkFBbUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsWUFBWSxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0QkFBNEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Qsb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsV0FBVztBQUMxRjtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxFQUFFLFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLG1EQUFtRCxvQkFBb0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxJQUFJLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSwwQkFBMEIsZ0JBQWdCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDLG9DQUFvQyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCLEVBQUUsNkJBQTZCO0FBQzVGO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCLEVBQUUsaUJBQWlCLEVBQUUsMEJBQTBCO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxRQUFRO0FBQ3ZFLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCLEVBQUUsd0RBQXdEO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4c0NBQThzQztBQUM5c0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0EsMkNBQTJDLElBQUksMkNBQTJDLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSywwQkFBMEIsOENBQThDLGNBQWMsK0JBQStCLE1BQU0sT0FBTztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0MsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQ0FBZ0M7QUFDakYsMkJBQTJCLFFBQVEsRUFBRSxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyx1Q0FBdUMsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0JBQXNCO0FBQzlFO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hELHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUEwRDtBQUMxRixtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw2QkFBNkI7QUFDdEg7QUFDQTtBQUNBLHdGQUF3Riw2QkFBNkI7QUFDckg7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLElBQUksTUFBTTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFdBQVcsV0FBVztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSyxFQUFFLE9BQU8sSUFBSTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSx1QkFBdUIsS0FBSztBQUN4RjtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUscUJBQXFCLEtBQUs7QUFDdEY7QUFDQTtBQUNBLDBDQUEwQyxNQUFNLGtCQUFrQixPQUFPLDJCQUEyQixrQkFBa0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEIsaUJBQWlCLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHdCQUF3QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixTQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QixNQUFNLGNBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsUUFBUTtBQUMxRSx1QkFBdUIsYUFBYSxJQUFJLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLG9CQUFvQjtBQUNuSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFLHdCQUF3QixtQ0FBbUM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxPQUFPO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsc0NBQXNDLGNBQWM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQ0FBb0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0RBQWtEO0FBQzlGO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLFlBQVk7QUFDWixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsbUNBQW1DO0FBQ25DLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2xpbmt1cy9HaXRodWIvbW9ub3R3by9wYXlsb2FkLXBsdWdpbi1tZXRhL25vZGVfbW9kdWxlcy8ucG5wbS9ic29uQDYuMTAuMS9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGcgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSksIFN5bWJvbC50b1N0cmluZ1RhZykuZ2V0O1xuICAgIHJldHVybiAodmFsdWUpID0+IGcuY2FsbCh2YWx1ZSk7XG59KSgpO1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUgJiZcbiAgICAgICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicpKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlZ2V4cCkge1xuICAgIHJldHVybiByZWdleHAgaW5zdGFuY2VvZiBSZWdFeHAgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlZ2V4cCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUgJiZcbiAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01hcCcpO1xufVxuZnVuY3Rpb24gaXNEYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5mdW5jdGlvbiBkZWZhdWx0SW5zcGVjdCh4LCBfb3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4LCAoaywgdikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogYCR7dn1gIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNYXAodikpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdHlsaXplRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHN0eWxpemVFeGlzdHMgPSBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdzdHlsaXplJyBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnN0eWxpemUgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHN0eWxpemVFeGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZTtcbiAgICB9XG59XG5cbmNvbnN0IEJTT05fTUFKT1JfVkVSU0lPTiA9IDY7XG5jb25zdCBCU09OX1ZFUlNJT05fU1lNQk9MID0gU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyk7XG5jb25zdCBCU09OX0lOVDMyX01BWCA9IDB4N2ZmZmZmZmY7XG5jb25zdCBCU09OX0lOVDMyX01JTiA9IC0weDgwMDAwMDAwO1xuY29uc3QgQlNPTl9JTlQ2NF9NQVggPSBNYXRoLnBvdygyLCA2MykgLSAxO1xuY29uc3QgQlNPTl9JTlQ2NF9NSU4gPSAtTWF0aC5wb3coMiwgNjMpO1xuY29uc3QgSlNfSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEpTX0lOVF9NSU4gPSAtTWF0aC5wb3coMiwgNTMpO1xuY29uc3QgQlNPTl9EQVRBX05VTUJFUiA9IDE7XG5jb25zdCBCU09OX0RBVEFfU1RSSU5HID0gMjtcbmNvbnN0IEJTT05fREFUQV9PQkpFQ1QgPSAzO1xuY29uc3QgQlNPTl9EQVRBX0FSUkFZID0gNDtcbmNvbnN0IEJTT05fREFUQV9CSU5BUlkgPSA1O1xuY29uc3QgQlNPTl9EQVRBX1VOREVGSU5FRCA9IDY7XG5jb25zdCBCU09OX0RBVEFfT0lEID0gNztcbmNvbnN0IEJTT05fREFUQV9CT09MRUFOID0gODtcbmNvbnN0IEJTT05fREFUQV9EQVRFID0gOTtcbmNvbnN0IEJTT05fREFUQV9OVUxMID0gMTA7XG5jb25zdCBCU09OX0RBVEFfUkVHRVhQID0gMTE7XG5jb25zdCBCU09OX0RBVEFfREJQT0lOVEVSID0gMTI7XG5jb25zdCBCU09OX0RBVEFfQ09ERSA9IDEzO1xuY29uc3QgQlNPTl9EQVRBX1NZTUJPTCA9IDE0O1xuY29uc3QgQlNPTl9EQVRBX0NPREVfV19TQ09QRSA9IDE1O1xuY29uc3QgQlNPTl9EQVRBX0lOVCA9IDE2O1xuY29uc3QgQlNPTl9EQVRBX1RJTUVTVEFNUCA9IDE3O1xuY29uc3QgQlNPTl9EQVRBX0xPTkcgPSAxODtcbmNvbnN0IEJTT05fREFUQV9ERUNJTUFMMTI4ID0gMTk7XG5jb25zdCBCU09OX0RBVEFfTUlOX0tFWSA9IDB4ZmY7XG5jb25zdCBCU09OX0RBVEFfTUFYX0tFWSA9IDB4N2Y7XG5jb25zdCBCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQgPSAwO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyA9IDQ7XG5jb25zdCBCU09OVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGRvdWJsZTogMSxcbiAgICBzdHJpbmc6IDIsXG4gICAgb2JqZWN0OiAzLFxuICAgIGFycmF5OiA0LFxuICAgIGJpbkRhdGE6IDUsXG4gICAgdW5kZWZpbmVkOiA2LFxuICAgIG9iamVjdElkOiA3LFxuICAgIGJvb2w6IDgsXG4gICAgZGF0ZTogOSxcbiAgICBudWxsOiAxMCxcbiAgICByZWdleDogMTEsXG4gICAgZGJQb2ludGVyOiAxMixcbiAgICBqYXZhc2NyaXB0OiAxMyxcbiAgICBzeW1ib2w6IDE0LFxuICAgIGphdmFzY3JpcHRXaXRoU2NvcGU6IDE1LFxuICAgIGludDogMTYsXG4gICAgdGltZXN0YW1wOiAxNyxcbiAgICBsb25nOiAxOCxcbiAgICBkZWNpbWFsOiAxOSxcbiAgICBtaW5LZXk6IC0xLFxuICAgIG1heEtleTogMTI3XG59KTtcblxuY2xhc3MgQlNPTkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBic29uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09ORXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNCU09ORXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnYnNvbkVycm9yJyBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUuYnNvbkVycm9yID09PSB0cnVlICYmXG4gICAgICAgICAgICAnbmFtZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgJ3N0YWNrJyBpbiB2YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgQlNPTlZlcnNpb25FcnJvciBleHRlbmRzIEJTT05FcnJvciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTlZlcnNpb25FcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgVW5zdXBwb3J0ZWQgQlNPTiB2ZXJzaW9uLCBic29uIHR5cGVzIG11c3QgYmUgZnJvbSBic29uICR7QlNPTl9NQUpPUl9WRVJTSU9OfS54LnhgKTtcbiAgICB9XG59XG5jbGFzcyBCU09OUnVudGltZUVycm9yIGV4dGVuZHMgQlNPTkVycm9yIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OUnVudGltZUVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBCU09OT2Zmc2V0RXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05PZmZzZXRFcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihgJHttZXNzYWdlfS4gb2Zmc2V0OiAke29mZnNldH1gLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxufVxuXG5sZXQgVGV4dERlY29kZXJGYXRhbDtcbmxldCBUZXh0RGVjb2Rlck5vbkZhdGFsO1xuZnVuY3Rpb24gcGFyc2VVdGY4KGJ1ZmZlciwgc3RhcnQsIGVuZCwgZmF0YWwpIHtcbiAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgVGV4dERlY29kZXJGYXRhbCA/Pz0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBUZXh0RGVjb2RlckZhdGFsLmRlY29kZShidWZmZXIuc3ViYXJyYXkoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCBzdHJpbmcgaW4gQlNPTiBkb2N1bWVudCcsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERlY29kZXJOb25GYXRhbCA/Pz0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIFRleHREZWNvZGVyTm9uRmF0YWwuZGVjb2RlKGJ1ZmZlci5zdWJhcnJheShzdGFydCwgZW5kKSk7XG59XG5cbmZ1bmN0aW9uIHRyeVJlYWRCYXNpY0xhdGluKHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodWludDhhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdCeXRlTGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHN0cmluZ0J5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA+IDIwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA9PT0gMSAmJiB1aW50OGFycmF5W3N0YXJ0XSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0XSk7XG4gICAgfVxuICAgIGlmIChzdHJpbmdCeXRlTGVuZ3RoID09PSAyICYmIHVpbnQ4YXJyYXlbc3RhcnRdIDwgMTI4ICYmIHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0XSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSk7XG4gICAgfVxuICAgIGlmIChzdHJpbmdCeXRlTGVuZ3RoID09PSAzICYmXG4gICAgICAgIHVpbnQ4YXJyYXlbc3RhcnRdIDwgMTI4ICYmXG4gICAgICAgIHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSA8IDEyOCAmJlxuICAgICAgICB1aW50OGFycmF5W3N0YXJ0ICsgMl0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIChTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnRdKSArXG4gICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSkgK1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0ICsgMl0pKTtcbiAgICB9XG4gICAgY29uc3QgbGF0aW5CeXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSB1aW50OGFycmF5W2ldO1xuICAgICAgICBpZiAoYnl0ZSA+IDEyNykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGF0aW5CeXRlcy5wdXNoKGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5sYXRpbkJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHRyeVdyaXRlQmFzaWNMYXRpbihkZXN0aW5hdGlvbiwgc291cmNlLCBvZmZzZXQpIHtcbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPiAyNSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmxlbmd0aCAtIG9mZnNldCA8IHNvdXJjZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGZvciAobGV0IGNoYXJPZmZzZXQgPSAwLCBkZXN0aW5hdGlvbk9mZnNldCA9IG9mZnNldDsgY2hhck9mZnNldCA8IHNvdXJjZS5sZW5ndGg7IGNoYXJPZmZzZXQrKywgZGVzdGluYXRpb25PZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc291cmNlLmNoYXJDb2RlQXQoY2hhck9mZnNldCk7XG4gICAgICAgIGlmIChjaGFyID4gMTI3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlc3RpbmF0aW9uW2Rlc3RpbmF0aW9uT2Zmc2V0XSA9IGNoYXI7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBub2RlanNNYXRoUmFuZG9tQnl0ZXMoYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KEFycmF5LmZyb20oeyBsZW5ndGg6IGJ5dGVMZW5ndGggfSwgKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSkpO1xufVxuY29uc3Qgbm9kZWpzUmFuZG9tQnl0ZXMgPSAoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbm9kZWpzTWF0aFJhbmRvbUJ5dGVzO1xuICAgIH1cbn0pKCk7XG5jb25zdCBub2RlSnNCeXRlVXRpbHMgPSB7XG4gICAgdG9Mb2NhbEJ1ZmZlclR5cGUocG90ZW50aWFsQnVmZmVyKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocG90ZW50aWFsQnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbEJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBvdGVudGlhbEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwb3RlbnRpYWxCdWZmZXIuYnVmZmVyLCBwb3RlbnRpYWxCdWZmZXIuYnl0ZU9mZnNldCwgcG90ZW50aWFsQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZ1RhZyA9IHBvdGVudGlhbEJ1ZmZlcj8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPz8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBvdGVudGlhbEJ1ZmZlcik7XG4gICAgICAgIGlmIChzdHJpbmdUYWcgPT09ICdBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1NoYXJlZEFycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwb3RlbnRpYWxCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYENhbm5vdCBjcmVhdGUgQnVmZmVyIGZyb20gdGhlIHBhc3NlZCBwb3RlbnRpYWxCdWZmZXIuYCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZVVuc2FmZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGEpLmVxdWFscyhiKTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyYXkpO1xuICAgIH0sXG4gICAgZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oY29kZVBvaW50cywgJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgdG9JU084ODU5MShidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICB9LFxuICAgIHRvSGV4KGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0sXG4gICAgdG9VVEY4KGJ1ZmZlciwgc3RhcnQsIGVuZCwgZmF0YWwpIHtcbiAgICAgICAgY29uc3QgYmFzaWNMYXRpbiA9IGVuZCAtIHN0YXJ0IDw9IDIwID8gdHJ5UmVhZEJhc2ljTGF0aW4oYnVmZmVyLCBzdGFydCwgZW5kKSA6IG51bGw7XG4gICAgICAgIGlmIChiYXNpY0xhdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY0xhdGluO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IDB4ZmZmZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVV0ZjgoYnVmZmVyLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfSxcbiAgICB1dGY4Qnl0ZUxlbmd0aChpbnB1dCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoaW5wdXQsICd1dGY4Jyk7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byhidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBsYXRpbkJ5dGVzV3JpdHRlbiA9IHRyeVdyaXRlQmFzaWNMYXRpbihidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCk7XG4gICAgICAgIGlmIChsYXRpbkJ5dGVzV3JpdHRlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF0aW5CeXRlc1dyaXR0ZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLndyaXRlKHNvdXJjZSwgYnl0ZU9mZnNldCwgdW5kZWZpbmVkLCAndXRmOCcpO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IG5vZGVqc1JhbmRvbUJ5dGVzLFxuICAgIHN3YXAzMihidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnN3YXAzMigpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gICAgY29uc3QgeyBuYXZpZ2F0b3IgfSA9IGdsb2JhbFRoaXM7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gd2ViTWF0aFJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSBhcmd1bWVudCAnYnl0ZUxlbmd0aCcgaXMgaW52YWxpZC4gUmVjZWl2ZWQgJHtieXRlTGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gd2ViQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShBcnJheS5mcm9tKHsgbGVuZ3RoOiBieXRlTGVuZ3RoIH0sICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpKTtcbn1cbmNvbnN0IHdlYlJhbmRvbUJ5dGVzID0gKCgpID0+IHtcbiAgICBjb25zdCB7IGNyeXB0byB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoY3J5cHRvICE9IG51bGwgJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChieXRlTGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh3ZWJCeXRlVXRpbHMuYWxsb2NhdGUoYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgY29uc3QgeyBjb25zb2xlIH0gPSBnbG9iYWxUaGlzO1xuICAgICAgICAgICAgY29uc29sZT8ud2Fybj8uKCdCU09OOiBGb3IgUmVhY3QgTmF0aXZlIHBsZWFzZSBwb2x5ZmlsbCBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLCBlLmcuIHVzaW5nOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZWFjdC1uYXRpdmUtZ2V0LXJhbmRvbS12YWx1ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYk1hdGhSYW5kb21CeXRlcztcbiAgICB9XG59KSgpO1xuY29uc3QgSEVYX0RJR0lUID0gLyhcXGR8W2EtZl0pL2k7XG5jb25zdCB3ZWJCeXRlVXRpbHMgPSB7XG4gICAgdG9Mb2NhbEJ1ZmZlclR5cGUocG90ZW50aWFsVWludDhhcnJheSkge1xuICAgICAgICBjb25zdCBzdHJpbmdUYWcgPSBwb3RlbnRpYWxVaW50OGFycmF5Py5bU3ltYm9sLnRvU3RyaW5nVGFnXSA/P1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBvdGVudGlhbFVpbnQ4YXJyYXkpO1xuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnVWludDhBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxVaW50OGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocG90ZW50aWFsVWludDhhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwb3RlbnRpYWxVaW50OGFycmF5LmJ1ZmZlci5zbGljZShwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVPZmZzZXQsIHBvdGVudGlhbFVpbnQ4YXJyYXkuYnl0ZU9mZnNldCArIHBvdGVudGlhbFVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdUYWcgPT09ICdBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1NoYXJlZEFycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwb3RlbnRpYWxVaW50OGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBDYW5ub3QgbWFrZSBhIFVpbnQ4QXJyYXkgZnJvbSBwYXNzZWQgcG90ZW50aWFsQnVmZmVyLmApO1xuICAgIH0sXG4gICAgYWxsb2NhdGUoc2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgJHtTdHJpbmcoc2l6ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH0sXG4gICAgYWxsb2NhdGVVbnNhZmUoc2l6ZSkge1xuICAgICAgICByZXR1cm4gd2ViQnl0ZVV0aWxzLmFsbG9jYXRlKHNpemUpO1xuICAgIH0sXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmcm9tTnVtYmVyQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnJheSk7XG4gICAgfSxcbiAgICBmcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0KSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gYnRvYSh3ZWJCeXRlVXRpbHMudG9JU084ODU5MSh1aW50OGFycmF5KSk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvZGVQb2ludHMsIGMgPT4gYy5jaGFyQ29kZUF0KDApICYgMHhmZik7XG4gICAgfSxcbiAgICB0b0lTTzg4NTkxKHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oVWludDE2QXJyYXkuZnJvbSh1aW50OGFycmF5KSwgYiA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGV2ZW5MZW5ndGhIZXggPSBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGhleC5zbGljZSgwLCBoZXgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW5MZW5ndGhIZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSBldmVuTGVuZ3RoSGV4W2ldO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kRGlnaXQgPSBldmVuTGVuZ3RoSGV4W2kgKyAxXTtcbiAgICAgICAgICAgIGlmICghSEVYX0RJR0lULnRlc3QoZmlyc3REaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSEVYX0RJR0lULnRlc3Qoc2Vjb25kRGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhEaWdpdCA9IE51bWJlci5wYXJzZUludChgJHtmaXJzdERpZ2l0fSR7c2Vjb25kRGlnaXR9YCwgMTYpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goaGV4RGlnaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICB9LFxuICAgIHRvSGV4KHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odWludDhhcnJheSwgYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIHRvVVRGOCh1aW50OGFycmF5LCBzdGFydCwgZW5kLCBmYXRhbCkge1xuICAgICAgICBjb25zdCBiYXNpY0xhdGluID0gZW5kIC0gc3RhcnQgPD0gMjAgPyB0cnlSZWFkQmFzaWNMYXRpbih1aW50OGFycmF5LCBzdGFydCwgZW5kKSA6IG51bGw7XG4gICAgICAgIGlmIChiYXNpY0xhdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY0xhdGluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVV0ZjgodWludDhhcnJheSwgc3RhcnQsIGVuZCwgZmF0YWwpO1xuICAgIH0sXG4gICAgdXRmOEJ5dGVMZW5ndGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkuYnl0ZUxlbmd0aDtcbiAgICB9LFxuICAgIGVuY29kZVVURjhJbnRvKHVpbnQ4YXJyYXksIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzb3VyY2UpO1xuICAgICAgICB1aW50OGFycmF5LnNldChieXRlcywgYnl0ZU9mZnNldCk7XG4gICAgICAgIHJldHVybiBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IHdlYlJhbmRvbUJ5dGVzLFxuICAgIHN3YXAzMihidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTAgPSBidWZmZXJbaV07XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGJ1ZmZlcltpICsgMl07XG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGJ1ZmZlcltpICsgM107XG4gICAgICAgICAgICBidWZmZXJbaV0gPSBieXRlMztcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPSBieXRlMjtcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMl0gPSBieXRlMTtcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgM10gPSBieXRlMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn07XG5cbmNvbnN0IGhhc0dsb2JhbEJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLnByb3RvdHlwZT8uX2lzQnVmZmVyICE9PSB0cnVlO1xuY29uc3QgQnl0ZVV0aWxzID0gaGFzR2xvYmFsQnVmZmVyID8gbm9kZUpzQnl0ZVV0aWxzIDogd2ViQnl0ZVV0aWxzO1xuXG5jbGFzcyBCU09OVmFsdWUge1xuICAgIGdldCBbQlNPTl9WRVJTSU9OX1NZTUJPTF0oKSB7XG4gICAgICAgIHJldHVybiBCU09OX01BSk9SX1ZFUlNJT047XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXShkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KTtcbiAgICB9XG59XG5cbmNvbnN0IEZMT0FUID0gbmV3IEZsb2F0NjRBcnJheSgxKTtcbmNvbnN0IEZMT0FUX0JZVEVTID0gbmV3IFVpbnQ4QXJyYXkoRkxPQVQuYnVmZmVyLCAwLCA4KTtcbkZMT0FUWzBdID0gLTE7XG5jb25zdCBpc0JpZ0VuZGlhbiA9IEZMT0FUX0JZVEVTWzddID09PSAwO1xuY29uc3QgTnVtYmVyVXRpbHMgPSB7XG4gICAgaXNCaWdFbmRpYW4sXG4gICAgZ2V0Tm9ubmVnYXRpdmVJbnQzMkxFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChzb3VyY2Vbb2Zmc2V0ICsgM10gPiAxMjcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTaXplIGNhbm5vdCBiZSBuZWdhdGl2ZSBhdCBvZmZzZXQ6ICR7b2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc291cmNlW29mZnNldF0gfFxuICAgICAgICAgICAgKHNvdXJjZVtvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDNdIDw8IDI0KSk7XG4gICAgfSxcbiAgICBnZXRJbnQzMkxFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAoc291cmNlW29mZnNldF0gfFxuICAgICAgICAgICAgKHNvdXJjZVtvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDNdIDw8IDI0KSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzJMRShzb3VyY2UsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHNvdXJjZVtvZmZzZXRdICtcbiAgICAgICAgICAgIHNvdXJjZVtvZmZzZXQgKyAxXSAqIDI1NiArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgMl0gKiA2NTUzNiArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNik7XG4gICAgfSxcbiAgICBnZXRVaW50MzJCRShzb3VyY2UsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHNvdXJjZVtvZmZzZXQgKyAzXSArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgMl0gKiAyNTYgK1xuICAgICAgICAgICAgc291cmNlW29mZnNldCArIDFdICogNjU1MzYgK1xuICAgICAgICAgICAgc291cmNlW29mZnNldF0gKiAxNjc3NzIxNik7XG4gICAgfSxcbiAgICBnZXRCaWdJbnQ2NExFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGxvID0gTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoc291cmNlLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaSA9IE51bWJlclV0aWxzLmdldFVpbnQzMkxFKHNvdXJjZSwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0TEU6IGlzQmlnRW5kaWFuXG4gICAgICAgID8gKHNvdXJjZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s3XSA9IHNvdXJjZVtvZmZzZXRdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbNl0gPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s1XSA9IHNvdXJjZVtvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzRdID0gc291cmNlW29mZnNldCArIDNdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbM10gPSBzb3VyY2Vbb2Zmc2V0ICsgNF07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1syXSA9IHNvdXJjZVtvZmZzZXQgKyA1XTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzFdID0gc291cmNlW29mZnNldCArIDZdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbMF0gPSBzb3VyY2Vbb2Zmc2V0ICsgN107XG4gICAgICAgICAgICByZXR1cm4gRkxPQVRbMF07XG4gICAgICAgIH1cbiAgICAgICAgOiAoc291cmNlLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzBdID0gc291cmNlW29mZnNldF07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1sxXSA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzJdID0gc291cmNlW29mZnNldCArIDJdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbM10gPSBzb3VyY2Vbb2Zmc2V0ICsgM107XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s0XSA9IHNvdXJjZVtvZmZzZXQgKyA0XTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzVdID0gc291cmNlW29mZnNldCArIDVdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbNl0gPSBzb3VyY2Vbb2Zmc2V0ICsgNl07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s3XSA9IHNvdXJjZVtvZmZzZXQgKyA3XTtcbiAgICAgICAgICAgIHJldHVybiBGTE9BVFswXTtcbiAgICAgICAgfSxcbiAgICBzZXRJbnQzMkJFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDNdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMl0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfSxcbiAgICBzZXRJbnQzMkxFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgM10gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfSxcbiAgICBzZXRCaWdJbnQ2NExFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1hc2szMmJpdHMgPSBCaWdJbnQoMHhmZmZmX2ZmZmYpO1xuICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBtYXNrMzJiaXRzKTtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0XSA9IGxvO1xuICAgICAgICBsbyA+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMV0gPSBsbztcbiAgICAgICAgbG8gPj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gbG87XG4gICAgICAgIGxvID4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAzXSA9IGxvO1xuICAgICAgICBsZXQgaGkgPSBOdW1iZXIoKHZhbHVlID4+IEJpZ0ludCgzMikpICYgbWFzazMyYml0cyk7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDRdID0gaGk7XG4gICAgICAgIGhpID4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA1XSA9IGhpO1xuICAgICAgICBoaSA+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNl0gPSBoaTtcbiAgICAgICAgaGkgPj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDddID0gaGk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NExFOiBpc0JpZ0VuZGlhblxuICAgICAgICA/IChkZXN0aW5hdGlvbiwgb2Zmc2V0LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgRkxPQVRbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSBGTE9BVF9CWVRFU1s3XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDFdID0gRkxPQVRfQllURVNbNl07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAyXSA9IEZMT0FUX0JZVEVTWzVdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgM10gPSBGTE9BVF9CWVRFU1s0XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDRdID0gRkxPQVRfQllURVNbM107XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA1XSA9IEZMT0FUX0JZVEVTWzJdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNl0gPSBGTE9BVF9CWVRFU1sxXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDddID0gRkxPQVRfQllURVNbMF07XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICA6IChkZXN0aW5hdGlvbiwgb2Zmc2V0LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgRkxPQVRbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSBGTE9BVF9CWVRFU1swXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDFdID0gRkxPQVRfQllURVNbMV07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAyXSA9IEZMT0FUX0JZVEVTWzJdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgM10gPSBGTE9BVF9CWVRFU1szXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDRdID0gRkxPQVRfQllURVNbNF07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA1XSA9IEZMT0FUX0JZVEVTWzVdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNl0gPSBGTE9BVF9CWVRFU1s2XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDddID0gRkxPQVRfQllURVNbN107XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxufTtcblxuY2xhc3MgQmluYXJ5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JpbmFyeSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc3ViVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIShidWZmZXIgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikgJiZcbiAgICAgICAgICAgICFpc0FueUFycmF5QnVmZmVyKGJ1ZmZlcikgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBjYW4gb25seSBiZSBjb25zdHJ1Y3RlZCBmcm9tIFVpbnQ4QXJyYXkgb3IgbnVtYmVyW10nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Yl90eXBlID0gc3ViVHlwZSA/PyBCaW5hcnkuQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUO1xuICAgICAgICBpZiAoYnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKEJpbmFyeS5CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQXJyYXkuaXNBcnJheShidWZmZXIpXG4gICAgICAgICAgICAgICAgPyBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KGJ1ZmZlcilcbiAgICAgICAgICAgICAgICA6IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0KGJ5dGVWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ3N0cmluZycgJiYgYnl0ZVZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIHNpbmdsZSBjaGFyYWN0ZXIgU3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ5dGVWYWx1ZSAhPT0gJ251bWJlcicgJiYgYnl0ZVZhbHVlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBzaW5nbGUgY2hhcmFjdGVyIFVpbnQ4QXJyYXkgb3IgQXJyYXknKTtcbiAgICAgICAgbGV0IGRlY29kZWRCeXRlO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29kZWRCeXRlIDwgMCB8fCBkZWNvZGVkQnl0ZSA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIG51bWJlciBpbiBhIHZhbGlkIHVuc2lnbmVkIGJ5dGUgcmFuZ2UgMC0yNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA+IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBkZWNvZGVkQnl0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYWNlID0gQnl0ZVV0aWxzLmFsbG9jYXRlKEJpbmFyeS5CVUZGRVJfU0laRSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdTcGFjZS5zZXQodGhpcy5idWZmZXIsIDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdTcGFjZTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBkZWNvZGVkQnl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZShzZXF1ZW5jZSwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPCBvZmZzZXQgKyBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYWNlID0gQnl0ZVV0aWxzLmFsbG9jYXRlKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBzZXF1ZW5jZS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3U3BhY2Uuc2V0KHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3U3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnNldChCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoc2VxdWVuY2UpLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsgc2VxdWVuY2UuYnl0ZUxlbmd0aCA+IHRoaXMucG9zaXRpb24gPyBvZmZzZXQgKyBzZXF1ZW5jZS5sZW5ndGggOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lucHV0IGNhbm5vdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkKHBvc2l0aW9uLCBsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvc2l0aW9uLCBlbmQgPiB0aGlzLnBvc2l0aW9uID8gdGhpcy5wb3NpdGlvbiA6IGVuZCk7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICA/IHRoaXMuYnVmZmVyXG4gICAgICAgICAgICA6IHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvVVRGOCh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5wb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvVVRGOCh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5wb3NpdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfVkVDVE9SKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJpbmFyeVZlY3Rvcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBjb25zdCBzdWJUeXBlID0gTnVtYmVyKHRoaXMuc3ViX3R5cGUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICRiaW5hcnk6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICAkdHlwZTogc3ViVHlwZS5sZW5ndGggPT09IDEgPyAnMCcgKyBzdWJUeXBlIDogc3ViVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGJpbmFyeToge1xuICAgICAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHN1YlR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9VVUlEKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCaW5hcnkgc3ViX3R5cGUgXCIke3RoaXMuc3ViX3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgY29udmVydGluZyB0byBVVUlELiBPbmx5IFwiJHtCaW5hcnkuU1VCVFlQRV9VVUlEfVwiIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUhleChoZXgpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0LCBzdWJUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCksIHN1YlR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgaWYgKCckYmluYXJ5JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSAmJiB0eXBlb2YgZG9jLiRiaW5hcnkgPT09ICdzdHJpbmcnICYmICckdHlwZScgaW4gZG9jKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kdHlwZSA/IHBhcnNlSW50KGRvYy4kdHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJGJpbmFyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kYmluYXJ5LnN1YlR5cGUgPyBwYXJzZUludChkb2MuJGJpbmFyeS5zdWJUeXBlLCAxNikgOiAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkuYmFzZTY0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJyR1dWlkJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHR5cGUgPSA0O1xuICAgICAgICAgICAgZGF0YSA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGRvYy4kdXVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJpbmFyeSBFeHRlbmRlZCBKU09OIGZvcm1hdCAke0pTT04uc3RyaW5naWZ5KGRvYyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPyBuZXcgVVVJRChkYXRhKSA6IG5ldyBCaW5hcnkoZGF0YSwgdHlwZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGJhc2U2NEFyZyA9IGluc3BlY3QoYmFzZTY0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3ViVHlwZUFyZyA9IGluc3BlY3QodGhpcy5zdWJfdHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgQmluYXJ5LmNyZWF0ZUZyb21CYXNlNjQoJHtiYXNlNjRBcmd9LCAke3N1YlR5cGVBcmd9KWA7XG4gICAgfVxuICAgIHRvSW50OEFycmF5KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSAhPT0gQmluYXJ5LlNVQlRZUEVfVkVDVE9SKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgc3ViX3R5cGUgaXMgbm90IFZlY3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclswXSAhPT0gQmluYXJ5LlZFQ1RPUl9UWVBFLkludDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBkYXRhdHlwZSBmaWVsZCBpcyBub3QgSW50OCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHRoaXMuYnVmZmVyLmJ1ZmZlci5zbGljZSh0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgMiwgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24pKTtcbiAgICB9XG4gICAgdG9GbG9hdDMyQXJyYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yl90eXBlICE9PSBCaW5hcnkuU1VCVFlQRV9WRUNUT1IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBzdWJfdHlwZSBpcyBub3QgVmVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyWzBdICE9PSBCaW5hcnkuVkVDVE9SX1RZUEUuRmxvYXQzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IGRhdGF0eXBlIGZpZWxkIGlzIG5vdCBGbG9hdDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxvYXRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLmJ1ZmZlci5zbGljZSh0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgMiwgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCArIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgaWYgKE51bWJlclV0aWxzLmlzQmlnRW5kaWFuKVxuICAgICAgICAgICAgQnl0ZVV0aWxzLnN3YXAzMihmbG9hdEJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZmxvYXRCeXRlcy5idWZmZXIpO1xuICAgIH1cbiAgICB0b1BhY2tlZEJpdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yl90eXBlICE9PSBCaW5hcnkuU1VCVFlQRV9WRUNUT1IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBzdWJfdHlwZSBpcyBub3QgVmVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyWzBdICE9PSBCaW5hcnkuVkVDVE9SX1RZUEUuUGFja2VkQml0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgZGF0YXR5cGUgZmllbGQgaXMgbm90IHBhY2tlZCBiaXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIuYnVmZmVyLnNsaWNlKHRoaXMuYnVmZmVyLmJ5dGVPZmZzZXQgKyAyLCB0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbikpO1xuICAgIH1cbiAgICB0b0JpdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yl90eXBlICE9PSBCaW5hcnkuU1VCVFlQRV9WRUNUT1IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBzdWJfdHlwZSBpcyBub3QgVmVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyWzBdICE9PSBCaW5hcnkuVkVDVE9SX1RZUEUuUGFja2VkQml0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgZGF0YXR5cGUgZmllbGQgaXMgbm90IHBhY2tlZCBiaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlQ291bnQgPSB0aGlzLmxlbmd0aCgpIC0gMjtcbiAgICAgICAgY29uc3QgYml0Q291bnQgPSBieXRlQ291bnQgKiA4IC0gdGhpcy5idWZmZXJbMV07XG4gICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgSW50OEFycmF5KGJpdENvdW50KTtcbiAgICAgICAgZm9yIChsZXQgYml0T2Zmc2V0ID0gMDsgYml0T2Zmc2V0IDwgYml0cy5sZW5ndGg7IGJpdE9mZnNldCsrKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gKGJpdE9mZnNldCAvIDgpIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSB0aGlzLmJ1ZmZlcltieXRlT2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IDcgLSAoYml0T2Zmc2V0ICUgOCk7XG4gICAgICAgICAgICBjb25zdCBiaXQgPSAoYnl0ZSA+PiBzaGlmdCkgJiAxO1xuICAgICAgICAgICAgYml0c1tiaXRPZmZzZXRdID0gYml0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUludDhBcnJheShhcnJheSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoYXJyYXkuYnl0ZUxlbmd0aCArIDIpO1xuICAgICAgICBidWZmZXJbMF0gPSBCaW5hcnkuVkVDVE9SX1RZUEUuSW50ODtcbiAgICAgICAgYnVmZmVyWzFdID0gMDtcbiAgICAgICAgY29uc3QgaW50Qnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmZXIuc2V0KGludEJ5dGVzLCAyKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGJ1ZmZlciwgdGhpcy5TVUJUWVBFX1ZFQ1RPUik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRmxvYXQzMkFycmF5KGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeUJ5dGVzID0gQnl0ZVV0aWxzLmFsbG9jYXRlKGFycmF5LmJ5dGVMZW5ndGggKyAyKTtcbiAgICAgICAgYmluYXJ5Qnl0ZXNbMF0gPSBCaW5hcnkuVkVDVE9SX1RZUEUuRmxvYXQzMjtcbiAgICAgICAgYmluYXJ5Qnl0ZXNbMV0gPSAwO1xuICAgICAgICBjb25zdCBmbG9hdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkuYnVmZmVyLCBhcnJheS5ieXRlT2Zmc2V0LCBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYmluYXJ5Qnl0ZXMuc2V0KGZsb2F0Qnl0ZXMsIDIpO1xuICAgICAgICBpZiAoTnVtYmVyVXRpbHMuaXNCaWdFbmRpYW4pXG4gICAgICAgICAgICBCeXRlVXRpbHMuc3dhcDMyKG5ldyBVaW50OEFycmF5KGJpbmFyeUJ5dGVzLmJ1ZmZlciwgMikpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYmluYXJ5Qnl0ZXMsIHRoaXMuU1VCVFlQRV9WRUNUT1IpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhY2tlZEJpdHMoYXJyYXksIHBhZGRpbmcgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShhcnJheS5ieXRlTGVuZ3RoICsgMik7XG4gICAgICAgIGJ1ZmZlclswXSA9IEJpbmFyeS5WRUNUT1JfVFlQRS5QYWNrZWRCaXQ7XG4gICAgICAgIGJ1ZmZlclsxXSA9IHBhZGRpbmc7XG4gICAgICAgIGJ1ZmZlci5zZXQoYXJyYXksIDIpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYnVmZmVyLCB0aGlzLlNVQlRZUEVfVkVDVE9SKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGJpdHMpIHtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IChiaXRzLmxlbmd0aCArIDcpID4+PiAzO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGggKyAyKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBCaW5hcnkuVkVDVE9SX1RZUEUuUGFja2VkQml0O1xuICAgICAgICBjb25zdCByZW1haW5kZXIgPSBiaXRzLmxlbmd0aCAlIDg7XG4gICAgICAgIGJ5dGVzWzFdID0gcmVtYWluZGVyID09PSAwID8gMCA6IDggLSByZW1haW5kZXI7XG4gICAgICAgIGZvciAobGV0IGJpdE9mZnNldCA9IDA7IGJpdE9mZnNldCA8IGJpdHMubGVuZ3RoOyBiaXRPZmZzZXQrKykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGJpdE9mZnNldCA+Pj4gMztcbiAgICAgICAgICAgIGNvbnN0IGJpdCA9IGJpdHNbYml0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChiaXQgIT09IDAgJiYgYml0ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgSW52YWxpZCBiaXQgdmFsdWUgYXQgJHtiaXRPZmZzZXR9OiBtdXN0IGJlIDAgb3IgMSwgZm91bmQgJHtiaXRzW2JpdE9mZnNldF19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0ID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSA3IC0gKGJpdE9mZnNldCAlIDgpO1xuICAgICAgICAgICAgYnl0ZXNbYnl0ZU9mZnNldCArIDJdIHw9IGJpdCA8PCBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYnl0ZXMsIEJpbmFyeS5TVUJUWVBFX1ZFQ1RPUik7XG4gICAgfVxufVxuQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA9IDA7XG5CaW5hcnkuQlVGRkVSX1NJWkUgPSAyNTY7XG5CaW5hcnkuU1VCVFlQRV9ERUZBVUxUID0gMDtcbkJpbmFyeS5TVUJUWVBFX0ZVTkNUSU9OID0gMTtcbkJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkgPSAyO1xuQmluYXJ5LlNVQlRZUEVfVVVJRF9PTEQgPSAzO1xuQmluYXJ5LlNVQlRZUEVfVVVJRCA9IDQ7XG5CaW5hcnkuU1VCVFlQRV9NRDUgPSA1O1xuQmluYXJ5LlNVQlRZUEVfRU5DUllQVEVEID0gNjtcbkJpbmFyeS5TVUJUWVBFX0NPTFVNTiA9IDc7XG5CaW5hcnkuU1VCVFlQRV9TRU5TSVRJVkUgPSA4O1xuQmluYXJ5LlNVQlRZUEVfVkVDVE9SID0gOTtcbkJpbmFyeS5TVUJUWVBFX1VTRVJfREVGSU5FRCA9IDEyODtcbkJpbmFyeS5WRUNUT1JfVFlQRSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEludDg6IDB4MDMsXG4gICAgRmxvYXQzMjogMHgyNyxcbiAgICBQYWNrZWRCaXQ6IDB4MTBcbn0pO1xuZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlWZWN0b3IodmVjdG9yKSB7XG4gICAgaWYgKHZlY3Rvci5zdWJfdHlwZSAhPT0gQmluYXJ5LlNVQlRZUEVfVkVDVE9SKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgc2l6ZSA9IHZlY3Rvci5wb3NpdGlvbjtcbiAgICBjb25zdCBkYXRhdHlwZSA9IHZlY3Rvci5idWZmZXJbMF07XG4gICAgY29uc3QgcGFkZGluZyA9IHZlY3Rvci5idWZmZXJbMV07XG4gICAgaWYgKChkYXRhdHlwZSA9PT0gQmluYXJ5LlZFQ1RPUl9UWVBFLkZsb2F0MzIgfHwgZGF0YXR5cGUgPT09IEJpbmFyeS5WRUNUT1JfVFlQRS5JbnQ4KSAmJlxuICAgICAgICBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVmVjdG9yOiBwYWRkaW5nIG11c3QgYmUgemVybyBmb3IgaW50OCBhbmQgZmxvYXQzMiB2ZWN0b3JzJyk7XG4gICAgfVxuICAgIGlmIChkYXRhdHlwZSA9PT0gQmluYXJ5LlZFQ1RPUl9UWVBFLlBhY2tlZEJpdCAmJiBwYWRkaW5nICE9PSAwICYmIHNpemUgPT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBWZWN0b3I6IHBhZGRpbmcgbXVzdCBiZSB6ZXJvIGZvciBwYWNrZWQgYml0IHZlY3RvcnMgdGhhdCBhcmUgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKGRhdGF0eXBlID09PSBCaW5hcnkuVkVDVE9SX1RZUEUuUGFja2VkQml0ICYmIHBhZGRpbmcgPiA3KSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEludmFsaWQgVmVjdG9yOiBwYWRkaW5nIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDcuIGZvdW5kOiAke3BhZGRpbmd9YCk7XG4gICAgfVxufVxuY29uc3QgVVVJRF9CWVRFX0xFTkdUSCA9IDE2O1xuY29uc3QgVVVJRF9XSVRIT1VUX0RBU0hFUyA9IC9eWzAtOUEtRl17MzJ9JC9pO1xuY29uc3QgVVVJRF9XSVRIX0RBU0hFUyA9IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pO1xuY2xhc3MgVVVJRCBleHRlbmRzIEJpbmFyeSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBVVUlELmdlbmVyYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICBieXRlcyA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpICYmIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEgpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBieXRlcyA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBVVUlEIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBVVUlELCBhIDE2IGJ5dGUgQnVmZmVyIG9yIGEgMzIvMzYgY2hhcmFjdGVyIGhleCBzdHJpbmcgKGRhc2hlcyBleGNsdWRlZC9pbmNsdWRlZCwgZm9ybWF0OiB4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGJ5dGVzLCBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0hleFN0cmluZyhpbmNsdWRlRGFzaGVzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5jbHVkZURhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg0LCA2KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDYsIDgpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMTAsIDE2KSlcbiAgICAgICAgICAgIF0uam9pbignLScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVySWQpIHtcbiAgICAgICAgaWYgKCFvdGhlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVySWQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhvdGhlcklkLmlkLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5lcXVhbHMobmV3IFVVSUQob3RoZXJJZCkuaWQsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0JpbmFyeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkodGhpcy5pZCwgQmluYXJ5LlNVQlRZUEVfVVVJRCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMucmFuZG9tQnl0ZXMoVVVJRF9CWVRFX0xFTkdUSCk7XG4gICAgICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuICAgICAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZChpbnB1dCkge1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBVVUlELmlzVmFsaWRVVUlEU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVaW50OEFycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbnB1dC5fYnNvbnR5cGUgPT09ICdCaW5hcnknICYmXG4gICAgICAgICAgICBpbnB1dC5zdWJfdHlwZSA9PT0gdGhpcy5TVUJUWVBFX1VVSUQgJiZcbiAgICAgICAgICAgIGlucHV0LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAxNik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhoZXhTdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGJ5dGVzRnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICBpZiAoIVVVSUQuaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVVUlEIHN0cmluZyByZXByZXNlbnRhdGlvbiBtdXN0IGJlIDMyIGhleCBkaWdpdHMgb3IgY2Fub25pY2FsIGh5cGhlbmF0ZWQgcmVwcmVzZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmZyb21IZXgocmVwcmVzZW50YXRpb24ucmVwbGFjZSgvLS9nLCAnJykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFVVSURfV0lUSE9VVF9EQVNIRVMudGVzdChyZXByZXNlbnRhdGlvbikgfHwgVVVJRF9XSVRIX0RBU0hFUy50ZXN0KHJlcHJlc2VudGF0aW9uKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgVVVJRCgke2luc3BlY3QodGhpcy50b0hleFN0cmluZygpLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIENvZGUgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQ29kZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlID8/IG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29kZTogdGhpcy5jb2RlLCBzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMuY29kZSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUsICRzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZShkb2MuJGNvZGUsIGRvYy4kc2NvcGUpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBsZXQgcGFyYW1ldGVyc1N0cmluZyA9IGluc3BlY3QodGhpcy5jb2RlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbXVsdGlMaW5lRm4gPSBwYXJhbWV0ZXJzU3RyaW5nLmluY2x1ZGVzKCdcXG4nKTtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1N0cmluZyArPSBgLCR7bXVsdGlMaW5lRm4gPyAnXFxuJyA6ICcgJ30ke2luc3BlY3QodGhpcy5zY29wZSwgb3B0aW9ucyl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRpbmdOZXdsaW5lID0gbXVsdGlMaW5lRm4gJiYgdGhpcy5zY29wZSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGBuZXcgQ29kZSgke211bHRpTGluZUZuID8gJ1xcbicgOiAnJ30ke3BhcmFtZXRlcnNTdHJpbmd9JHtlbmRpbmdOZXdsaW5lID8gJ1xcbicgOiAnJ30pYDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzREJSZWZMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJyRpZCcgaW4gdmFsdWUgJiZcbiAgICAgICAgdmFsdWUuJGlkICE9IG51bGwgJiZcbiAgICAgICAgJyRyZWYnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS4kcmVmID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAoISgnJGRiJyBpbiB2YWx1ZSkgfHwgKCckZGInIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS4kZGIgPT09ICdzdHJpbmcnKSkpO1xufVxuY2xhc3MgREJSZWYgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnREJSZWYnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBvaWQsIGRiLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBjb2xsZWN0aW9uLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGRiID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMub2lkID0gb2lkO1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgbmFtZXNwYWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICRyZWY6IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgICAgICRpZDogdGhpcy5vaWRcbiAgICAgICAgfSwgdGhpcy5maWVsZHMpO1xuICAgICAgICBpZiAodGhpcy5kYiAhPSBudWxsKVxuICAgICAgICAgICAgby4kZGIgPSB0aGlzLmRiO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IG8gPSB7XG4gICAgICAgICAgICAkcmVmOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAkaWQ6IHRoaXMub2lkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGIpXG4gICAgICAgICAgICBvLiRkYiA9IHRoaXMuZGI7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKG8sIHRoaXMuZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZG9jKTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYoZG9jLiRyZWYsIGRvYy4kaWQsIGRvYy4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgaW5zcGVjdCh0aGlzLm5hbWVzcGFjZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBpbnNwZWN0KHRoaXMub2lkLCBvcHRpb25zKSxcbiAgICAgICAgICAgIC4uLih0aGlzLmRiID8gW2luc3BlY3QodGhpcy5kYiwgb3B0aW9ucyldIDogW10pLFxuICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5sZW5ndGggPiAwID8gW2luc3BlY3QodGhpcy5maWVsZHMsIG9wdGlvbnMpXSA6IFtdKVxuICAgICAgICBdO1xuICAgICAgICBhcmdzWzFdID0gaW5zcGVjdCA9PT0gZGVmYXVsdEluc3BlY3QgPyBgbmV3IE9iamVjdElkKCR7YXJnc1sxXX0pYCA6IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBgbmV3IERCUmVmKCR7YXJncy5qb2luKCcsICcpfSlgO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGVhZGluZ1plcm9zQW5kRXhwbGljaXRQbHVzKHN0cikge1xuICAgIGlmIChzdHIgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gc3RyW3N0YXJ0SW5kZXhdID09PSAnLSc7XG4gICAgY29uc3QgaXNFeHBsaWNpdGx5UG9zaXRpdmUgPSBzdHJbc3RhcnRJbmRleF0gPT09ICcrJztcbiAgICBpZiAoaXNFeHBsaWNpdGx5UG9zaXRpdmUgfHwgaXNOZWdhdGl2ZSkge1xuICAgICAgICBzdGFydEluZGV4ICs9IDE7XG4gICAgfVxuICAgIGxldCBmb3VuZEluc2lnbmlmaWNhbnRaZXJvID0gZmFsc2U7XG4gICAgZm9yICg7IHN0YXJ0SW5kZXggPCBzdHIubGVuZ3RoICYmIHN0cltzdGFydEluZGV4XSA9PT0gJzAnOyArK3N0YXJ0SW5kZXgpIHtcbiAgICAgICAgZm91bmRJbnNpZ25pZmljYW50WmVybyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghZm91bmRJbnNpZ25pZmljYW50WmVybykge1xuICAgICAgICByZXR1cm4gaXNFeHBsaWNpdGx5UG9zaXRpdmUgPyBzdHIuc2xpY2UoMSkgOiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBgJHtpc05lZ2F0aXZlID8gJy0nIDogJyd9JHtzdHIubGVuZ3RoID09PSBzdGFydEluZGV4ID8gJzAnIDogc3RyLnNsaWNlKHN0YXJ0SW5kZXgpfWA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0NoYXJhY3RlcnMoc3RyLCByYWRpeCkge1xuICAgIHJhZGl4ID0gcmFkaXggPz8gMTA7XG4gICAgY29uc3QgdmFsaWRDaGFyYWN0ZXJzID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc2xpY2UoMCwgcmFkaXgpO1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgW14tKyR7dmFsaWRDaGFyYWN0ZXJzfV1gLCAnaScpO1xuICAgIHJldHVybiByZWdleC50ZXN0KHN0cikgPyBmYWxzZSA6IHN0cjtcbn1cblxubGV0IHdhc20gPSB1bmRlZmluZWQ7XG50cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xufVxuY2F0Y2gge1xufVxuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG5jb25zdCBJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IFVJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIID0gMjA7XG5jb25zdCBERUNJTUFMX1JFR19FWCA9IC9eKFxcKz8wfChcXCt8LSk/WzEtOV1bMC05XSopJC87XG5jbGFzcyBMb25nIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0xvbmcnO1xuICAgIH1cbiAgICBnZXQgX19pc0xvbmdfXygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvd09yVmFsdWUgPSAwLCBoaWdoT3JVbnNpZ25lZCwgdW5zaWduZWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRCb29sID0gdHlwZW9mIGhpZ2hPclVuc2lnbmVkID09PSAnYm9vbGVhbicgPyBoaWdoT3JVbnNpZ25lZCA6IEJvb2xlYW4odW5zaWduZWQpO1xuICAgICAgICBjb25zdCBoaWdoID0gdHlwZW9mIGhpZ2hPclVuc2lnbmVkID09PSAnbnVtYmVyJyA/IGhpZ2hPclVuc2lnbmVkIDogMDtcbiAgICAgICAgY29uc3QgcmVzID0gdHlwZW9mIGxvd09yVmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IExvbmcuZnJvbVN0cmluZyhsb3dPclZhbHVlLCB1bnNpZ25lZEJvb2wpXG4gICAgICAgICAgICA6IHR5cGVvZiBsb3dPclZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tQmlnSW50KGxvd09yVmFsdWUsIHVuc2lnbmVkQm9vbClcbiAgICAgICAgICAgICAgICA6IHsgbG93OiBsb3dPclZhbHVlIHwgMCwgaGlnaDogaGlnaCB8IDAsIHVuc2lnbmVkOiB1bnNpZ25lZEJvb2wgfTtcbiAgICAgICAgdGhpcy5sb3cgPSByZXMubG93O1xuICAgICAgICB0aGlzLmhpZ2ggPSByZXMuaGlnaDtcbiAgICAgICAgdGhpcy51bnNpZ25lZCA9IHJlcy51bnNpZ25lZDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGxldCBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBjb25zdCBGUk9NX0JJR0lOVF9CSVRfTUFTSyA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICAgICAgY29uc3QgRlJPTV9CSUdJTlRfQklUX1NISUZUID0gQmlnSW50KDMyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKE51bWJlcih2YWx1ZSAmIEZST01fQklHSU5UX0JJVF9NQVNLKSwgTnVtYmVyKCh2YWx1ZSA+PiBGUk9NX0JJR0lOVF9CSVRfU0hJRlQpICYgRlJPTV9CSUdJTlRfQklUX01BU0spLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2VtcHR5IHN0cmluZycpO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLl9mcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFkaXhUb1Bvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA4KSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBMb25nLlpFUk87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgc2l6ZSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZ1N0cmljdChzdHIsIHVuc2lnbmVkT3JSYWRpeCwgcmFkaXgpIHtcbiAgICAgICAgbGV0IHVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWRPclJhZGl4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgKHJhZGl4ID0gdW5zaWduZWRPclJhZGl4KSwgKHVuc2lnbmVkT3JSYWRpeCA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZE9yUmFkaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmFkaXggPz89IDEwO1xuICAgICAgICBpZiAoc3RyLnRyaW0oKSAhPT0gc3RyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBJbnB1dDogJyR7c3RyfScgY29udGFpbnMgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgd2hpdGVzcGFjZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmdDaGFyYWN0ZXJzKHN0ciwgcmFkaXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBJbnB1dDogJyR7c3RyfScgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGZvciByYWRpeDogJHtyYWRpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbmVkU3RyID0gcmVtb3ZlTGVhZGluZ1plcm9zQW5kRXhwbGljaXRQbHVzKHN0cik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IExvbmcuX2Zyb21TdHJpbmcoY2xlYW5lZFN0ciwgdW5zaWduZWQsIHJhZGl4KTtcbiAgICAgICAgaWYgKHJlc3VsdC50b1N0cmluZyhyYWRpeCkudG9Mb3dlckNhc2UoKSAhPT0gY2xlYW5lZFN0ci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBJbnB1dDogJHtzdHJ9IGlzIG5vdCByZXByZXNlbnRhYmxlIGFzICR7cmVzdWx0LnVuc2lnbmVkID8gJ2FuIHVuc2lnbmVkJyA6ICdhIHNpZ25lZCd9IDY0LWJpdCBMb25nICR7cmFkaXggIT0gbnVsbCA/IGB3aXRoIHJhZGl4OiAke3JhZGl4fWAgOiAnJ31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkT3JSYWRpeCwgcmFkaXgpIHtcbiAgICAgICAgbGV0IHVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWRPclJhZGl4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgKHJhZGl4ID0gdW5zaWduZWRPclJhZGl4KSwgKHVuc2lnbmVkT3JSYWRpeCA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZE9yUmFkaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmFkaXggPz89IDEwO1xuICAgICAgICBpZiAoc3RyID09PSAnTmFOJyAmJiByYWRpeCA8IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzdHIgPT09ICdJbmZpbml0eScgfHwgc3RyID09PSAnK0luZmluaXR5JyB8fCBzdHIgPT09ICctSW5maW5pdHknKSAmJiByYWRpeCA8IDM1KSB7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb25nLl9mcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gICAgICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCAoYnl0ZXNbMV0gPDwgOCkgfCAoYnl0ZXNbMl0gPDwgMTYpIHwgKGJ5dGVzWzNdIDw8IDI0KSwgYnl0ZXNbNF0gfCAoYnl0ZXNbNV0gPDwgOCkgfCAoYnl0ZXNbNl0gPDwgMTYpIHwgKGJ5dGVzWzddIDw8IDI0KSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9uZygoYnl0ZXNbNF0gPDwgMjQpIHwgKGJ5dGVzWzVdIDw8IDE2KSB8IChieXRlc1s2XSA8PCA4KSB8IGJ5dGVzWzddLCAoYnl0ZXNbMF0gPDwgMjQpIHwgKGJ5dGVzWzFdIDw8IDE2KSB8IChieXRlc1syXSA8PCA4KSB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0xvbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnX19pc0xvbmdfXycgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLl9faXNMb25nX18gPT09IHRydWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xuICAgIH1cbiAgICBhZGQoYWRkZW5kKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoYWRkZW5kKSlcbiAgICAgICAgICAgIGFkZGVuZCA9IExvbmcuZnJvbVZhbHVlKGFkZGVuZCk7XG4gICAgICAgIGNvbnN0IGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIwMCA9IGFkZGVuZC5sb3cgJiAweGZmZmY7XG4gICAgICAgIGxldCBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgICAgICBjNDggJj0gMHhmZmZmO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHxcbiAgICAgICAgICAgIChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDApXG4gICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICA6IDE7XG4gICAgfVxuICAgIGNvbXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcik7XG4gICAgfVxuICAgIGRpdmlkZShkaXZpc29yKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoZGl2aXNvcikpXG4gICAgICAgICAgICBkaXZpc29yID0gTG9uZy5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignZGl2aXNpb24gYnkgemVybycpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxuICAgICAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICBsZXQgYXBwcm94LCByZW0sIHJlcztcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShMb25nLk9ORSkgfHwgZGl2aXNvci5lcShMb25nLk5FR19PTkUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fVkFMVUU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk9ORTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShMb25nLlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBMb25nLk9ORSA6IExvbmcuTkVHX09ORTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgICAgICAgICByZXMgPSBMb25nLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXG4gICAgICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuVVpFUk87XG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVPTkU7XG4gICAgICAgICAgICByZXMgPSBMb25nLlVaRVJPO1xuICAgICAgICB9XG4gICAgICAgIHJlbSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG4gICAgICAgICAgICBjb25zdCBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMik7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogTWF0aC5wb3coMiwgbG9nMiAtIDQ4KTtcbiAgICAgICAgICAgIGxldCBhcHByb3hSZXMgPSBMb25nLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgICAgIGxldCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5PTkU7XG4gICAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZGl2KGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKGRpdmlzb3IpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgZ2V0SGlnaEJpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgfVxuICAgIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gICAgfVxuICAgIGdldExvd0JpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdztcbiAgICB9XG4gICAgZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gICAgfVxuICAgIGdldE51bUJpdHNBYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmhpZ2ggIT09IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgICAgICAgbGV0IGJpdDtcbiAgICAgICAgZm9yIChiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXG4gICAgICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9PSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+IDA7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuKG90aGVyKTtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID49IDA7XG4gICAgfVxuICAgIGd0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBnZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBpc0V2ZW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG4gICAgfVxuICAgIGlzT2RkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gICAgfVxuICAgIGlzUG9zaXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gICAgfVxuICAgIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVzc1RoYW4ob3RoZXIpO1xuICAgIH1cbiAgICBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPD0gMDtcbiAgICB9XG4gICAgbHRlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIG1vZHVsbyhkaXZpc29yKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoZGl2aXNvcikpXG4gICAgICAgICAgICBkaXZpc29yID0gTG9uZy5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgICB9XG4gICAgbW9kKGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxvKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZW0oZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bG8oZGl2aXNvcik7XG4gICAgfVxuICAgIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG11bHRpcGxpZXIpKVxuICAgICAgICAgICAgbXVsdGlwbGllciA9IExvbmcuZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgY29uc3QgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBMb25nLk1JTl9WQUxVRSA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcbiAgICAgICAgaWYgKHRoaXMubHQoTG9uZy5UV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KExvbmcuVFdPX1BXUl8yNCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGNvbnN0IGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhmZmZmO1xuICAgICAgICBsZXQgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgbXVsKG11bHRpcGxpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkobXVsdGlwbGllcik7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoTG9uZy5PTkUpO1xuICAgIH1cbiAgICBuZWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xuICAgIH1cbiAgICBub3QoKSB7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG5vdEVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgbmVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG5lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNobChudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0TGVmdChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaHIobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KG51bUJpdHMpO1xuICAgIH1cbiAgICBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBudW1CaXRzICY9IDYzO1xuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSB0aGlzLmhpZ2g7XG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ID0gdGhpcy5sb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNocl91KG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpO1xuICAgIH1cbiAgICBzaHJ1KG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoc3VidHJhaGVuZCkpXG4gICAgICAgICAgICBzdWJ0cmFoZW5kID0gTG9uZy5mcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgICB9XG4gICAgc3ViKHN1YnRyYWhlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qoc3VidHJhaGVuZCk7XG4gICAgfVxuICAgIHRvSW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdG9CeXRlcyhsZSkge1xuICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbiAgICB9XG4gICAgdG9CeXRlc0xFKCkge1xuICAgICAgICBjb25zdCBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxvICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgbG8gPj4+IDI0LFxuICAgICAgICAgICAgaGkgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICBoaSA+Pj4gMjRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdG9CeXRlc0JFKCkge1xuICAgICAgICBjb25zdCBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhpID4+PiAyNCxcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgaGkgJiAweGZmLFxuICAgICAgICAgICAgbG8gPj4+IDI0LFxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgKGxvID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBsbyAmIDB4ZmZcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdG9TaWduZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3JhZGl4Jyk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpeExvbmcgPSBMb25nLmZyb21OdW1iZXIocmFkaXgpLCBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLCByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhZGl4VG9Qb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBsZXQgcmVtID0gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgY29uc3QgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDA7XG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9VbnNpZ25lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIGVxeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNaZXJvKCk7XG4gICAgfVxuICAgIGxlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1c2VCaWdJbnQ2NCA9IGZhbHNlLCByZWxheGVkID0gdHJ1ZSB9ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGlmIChkb2MuJG51bWJlckxvbmcubGVuZ3RoID4gTUFYX0lOVDY0X1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJyRudW1iZXJMb25nIHN0cmluZyBpcyB0b28gbG9uZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghREVDSU1BTF9SRUdfRVgudGVzdChkb2MuJG51bWJlckxvbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGAkbnVtYmVyTG9uZyBzdHJpbmcgXCIke2RvYy4kbnVtYmVyTG9uZ31cIiBpcyBpbiBhbiBpbnZhbGlkIGZvcm1hdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgY29uc3QgYmlnSW50UmVzdWx0ID0gQmlnSW50KGRvYy4kbnVtYmVyTG9uZyk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50LmFzSW50Tig2NCwgYmlnSW50UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb25nUmVzdWx0ID0gTG9uZy5mcm9tU3RyaW5nKGRvYy4kbnVtYmVyTG9uZyk7XG4gICAgICAgIGlmIChyZWxheGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9uZ1Jlc3VsdC50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb25nUmVzdWx0O1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBsb25nVmFsID0gaW5zcGVjdCh0aGlzLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1bnNpZ25lZFZhbCA9IHRoaXMudW5zaWduZWQgPyBgLCAke2luc3BlY3QodGhpcy51bnNpZ25lZCwgb3B0aW9ucyl9YCA6ICcnO1xuICAgICAgICByZXR1cm4gYG5ldyBMb25nKCR7bG9uZ1ZhbH0ke3Vuc2lnbmVkVmFsfSlgO1xuICAgIH1cbn1cbkxvbmcuVFdPX1BXUl8yNCA9IExvbmcuZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4ZmZmZmZmZmYgfCAwLCB0cnVlKTtcbkxvbmcuWkVSTyA9IExvbmcuZnJvbUludCgwKTtcbkxvbmcuVVpFUk8gPSBMb25nLmZyb21JbnQoMCwgdHJ1ZSk7XG5Mb25nLk9ORSA9IExvbmcuZnJvbUludCgxKTtcbkxvbmcuVU9ORSA9IExvbmcuZnJvbUludCgxLCB0cnVlKTtcbkxvbmcuTkVHX09ORSA9IExvbmcuZnJvbUludCgtMSk7XG5Mb25nLk1BWF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwLCBmYWxzZSk7XG5Mb25nLk1JTl9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcblxuY29uc3QgUEFSU0VfU1RSSU5HX1JFR0VYUCA9IC9eKFxcK3wtKT8oXFxkK3woXFxkKlxcLlxcZCopKT8oRXxlKT8oWy0rXSk/KFxcZCspPyQvO1xuY29uc3QgUEFSU0VfSU5GX1JFR0VYUCA9IC9eKFxcK3wtKT8oSW5maW5pdHl8aW5mKSQvaTtcbmNvbnN0IFBBUlNFX05BTl9SRUdFWFAgPSAvXihcXCt8LSk/TmFOJC9pO1xuY29uc3QgRVhQT05FTlRfTUFYID0gNjExMTtcbmNvbnN0IEVYUE9ORU5UX01JTiA9IC02MTc2O1xuY29uc3QgRVhQT05FTlRfQklBUyA9IDYxNzY7XG5jb25zdCBNQVhfRElHSVRTID0gMzQ7XG5jb25zdCBOQU5fQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHg3YywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgSU5GX05FR0FUSVZFX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4ZjgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IElORl9QT1NJVElWRV9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweDc4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBFWFBPTkVOVF9SRUdFWCA9IC9eKFstK10pPyhcXGQrKT8kLztcbmNvbnN0IENPTUJJTkFUSU9OX01BU0sgPSAweDFmO1xuY29uc3QgRVhQT05FTlRfTUFTSyA9IDB4M2ZmZjtcbmNvbnN0IENPTUJJTkFUSU9OX0lORklOSVRZID0gMzA7XG5jb25zdCBDT01CSU5BVElPTl9OQU4gPSAzMTtcbmZ1bmN0aW9uIGlzRGlnaXQodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xufVxuZnVuY3Rpb24gZGl2aWRldTEyOCh2YWx1ZSkge1xuICAgIGNvbnN0IERJVklTT1IgPSBMb25nLmZyb21OdW1iZXIoMTAwMCAqIDEwMDAgKiAxMDAwKTtcbiAgICBsZXQgX3JlbSA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICBpZiAoIXZhbHVlLnBhcnRzWzBdICYmICF2YWx1ZS5wYXJ0c1sxXSAmJiAhdmFsdWUucGFydHNbMl0gJiYgIXZhbHVlLnBhcnRzWzNdKSB7XG4gICAgICAgIHJldHVybiB7IHF1b3RpZW50OiB2YWx1ZSwgcmVtOiBfcmVtIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDM7IGkrKykge1xuICAgICAgICBfcmVtID0gX3JlbS5zaGlmdExlZnQoMzIpO1xuICAgICAgICBfcmVtID0gX3JlbS5hZGQobmV3IExvbmcodmFsdWUucGFydHNbaV0sIDApKTtcbiAgICAgICAgdmFsdWUucGFydHNbaV0gPSBfcmVtLmRpdihESVZJU09SKS5sb3c7XG4gICAgICAgIF9yZW0gPSBfcmVtLm1vZHVsbyhESVZJU09SKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcXVvdGllbnQ6IHZhbHVlLCByZW06IF9yZW0gfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5NjR4MihsZWZ0LCByaWdodCkge1xuICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHsgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApLCBsb3c6IExvbmcuZnJvbU51bWJlcigwKSB9O1xuICAgIH1cbiAgICBjb25zdCBsZWZ0SGlnaCA9IGxlZnQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKTtcbiAgICBjb25zdCBsZWZ0TG93ID0gbmV3IExvbmcobGVmdC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGNvbnN0IHJpZ2h0SGlnaCA9IHJpZ2h0LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMik7XG4gICAgY29uc3QgcmlnaHRMb3cgPSBuZXcgTG9uZyhyaWdodC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGxldCBwcm9kdWN0SGlnaCA9IGxlZnRIaWdoLm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RNaWQgPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodExvdyk7XG4gICAgY29uc3QgcHJvZHVjdE1pZDIgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RMb3cgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0TG93KTtcbiAgICBwcm9kdWN0SGlnaCA9IHByb2R1Y3RIaWdoLmFkZChwcm9kdWN0TWlkLnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RNaWQgPSBuZXcgTG9uZyhwcm9kdWN0TWlkLmdldExvd0JpdHMoKSwgMClcbiAgICAgICAgLmFkZChwcm9kdWN0TWlkMilcbiAgICAgICAgLmFkZChwcm9kdWN0TG93LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RIaWdoID0gcHJvZHVjdEhpZ2guYWRkKHByb2R1Y3RNaWQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG4gICAgcHJvZHVjdExvdyA9IHByb2R1Y3RNaWQuc2hpZnRMZWZ0KDMyKS5hZGQobmV3IExvbmcocHJvZHVjdExvdy5nZXRMb3dCaXRzKCksIDApKTtcbiAgICByZXR1cm4geyBoaWdoOiBwcm9kdWN0SGlnaCwgbG93OiBwcm9kdWN0TG93IH07XG59XG5mdW5jdGlvbiBsZXNzVGhhbihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHVobGVmdCA9IGxlZnQuaGlnaCA+Pj4gMDtcbiAgICBjb25zdCB1aHJpZ2h0ID0gcmlnaHQuaGlnaCA+Pj4gMDtcbiAgICBpZiAodWhsZWZ0IDwgdWhyaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodWhsZWZ0ID09PSB1aHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHVsbGVmdCA9IGxlZnQubG93ID4+PiAwO1xuICAgICAgICBjb25zdCB1bHJpZ2h0ID0gcmlnaHQubG93ID4+PiAwO1xuICAgICAgICBpZiAodWxsZWZ0IDwgdWxyaWdodClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnZhbGlkRXJyKHN0cmluZywgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFwiJHtzdHJpbmd9XCIgaXMgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcgLSAke21lc3NhZ2V9YCk7XG59XG5jbGFzcyBEZWNpbWFsMTI4IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RlY2ltYWwxMjgnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IERlY2ltYWwxMjguZnJvbVN0cmluZyhieXRlcykuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGlzVWludDhBcnJheShieXRlcykpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0RlY2ltYWwxMjggbXVzdCB0YWtlIGEgQnVmZmVyIG9mIDE2IGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdEZWNpbWFsMTI4IG11c3QgdGFrZSBhIEJ1ZmZlciBvciBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5fZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgeyBhbGxvd1JvdW5kaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmdXaXRoUm91bmRpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIHsgYWxsb3dSb3VuZGluZzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdTaWduID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdSYWRpeCA9IGZhbHNlO1xuICAgICAgICBsZXQgZm91bmROb25aZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzUmVhZCA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzID0gMDtcbiAgICAgICAgbGV0IHJhZGl4UG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgZmlyc3ROb25aZXJvID0gMDtcbiAgICAgICAgY29uc3QgZGlnaXRzID0gWzBdO1xuICAgICAgICBsZXQgbkRpZ2l0c1N0b3JlZCA9IDA7XG4gICAgICAgIGxldCBkaWdpdHNJbnNlcnQgPSAwO1xuICAgICAgICBsZXQgbGFzdERpZ2l0ID0gMDtcbiAgICAgICAgbGV0IGV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRMb3cgPSBuZXcgTG9uZygwLCAwKTtcbiAgICAgICAgbGV0IGJpYXNlZEV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uLmxlbmd0aCA+PSA3MDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaW5nTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9TVFJJTkdfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgaW5mTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9JTkZfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgbmFuTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9OQU5fUkVHRVhQKTtcbiAgICAgICAgaWYgKCghc3RyaW5nTWF0Y2ggJiYgIWluZk1hdGNoICYmICFuYW5NYXRjaCkgfHwgcmVwcmVzZW50YXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZE51bWJlciA9IHN0cmluZ01hdGNoWzJdO1xuICAgICAgICAgICAgY29uc3QgZSA9IHN0cmluZ01hdGNoWzRdO1xuICAgICAgICAgICAgY29uc3QgZXhwU2lnbiA9IHN0cmluZ01hdGNoWzVdO1xuICAgICAgICAgICAgY29uc3QgZXhwTnVtYmVyID0gc3RyaW5nTWF0Y2hbNl07XG4gICAgICAgICAgICBpZiAoZSAmJiBleHBOdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBwb3dlcicpO1xuICAgICAgICAgICAgaWYgKGUgJiYgdW5zaWduZWROdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBiYXNlJyk7XG4gICAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkICYmIChleHBTaWduIHx8IGV4cE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBlIGJlZm9yZSBleHBvbmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcrJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICctJykge1xuICAgICAgICAgICAgc2F3U2lnbiA9IHRydWU7XG4gICAgICAgICAgICBpc05lZ2F0aXZlID0gcmVwcmVzZW50YXRpb25baW5kZXgrK10gPT09ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRGlnaXQocmVwcmVzZW50YXRpb25baW5kZXhdKSAmJiByZXByZXNlbnRhdGlvbltpbmRleF0gIT09ICcuJykge1xuICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ2knIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdOJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNEaWdpdChyZXByZXNlbnRhdGlvbltpbmRleF0pIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdjb250YWlucyBtdWx0aXBsZSBwZXJpb2RzJyk7XG4gICAgICAgICAgICAgICAgc2F3UmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBNQVhfRElHSVRTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSAhPT0gJzAnIHx8IGZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gbkRpZ2l0c1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm91bmROb25aZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzW2RpZ2l0c0luc2VydCsrXSA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2luZGV4XSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gbkRpZ2l0c1N0b3JlZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kTm9uWmVybylcbiAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyArIDE7XG4gICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgcmFkaXhQb3NpdGlvbiA9IHJhZGl4UG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgbkRpZ2l0c1JlYWQgPSBuRGlnaXRzUmVhZCArIDE7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F3UmFkaXggJiYgIW5EaWdpdHNSZWFkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJyArIHJlcHJlc2VudGF0aW9uICsgJyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZycpO1xuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnZScgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnRScpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVwcmVzZW50YXRpb24uc3Vic3RyKCsraW5kZXgpLm1hdGNoKEVYUE9ORU5UX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzJdKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQobWF0Y2hbMF0sIDEwKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgaWYgKCFuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICBkaWdpdHNbMF0gPSAwO1xuICAgICAgICAgICAgbkRpZ2l0cyA9IDE7XG4gICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IG5EaWdpdHNTdG9yZWQgLSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBuRGlnaXRzO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIHNpZ25pZmljYW50RGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBzaWduaWZpY2FudERpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvbmVudCA8PSByYWRpeFBvc2l0aW9uICYmIHJhZGl4UG9zaXRpb24gPiBleHBvbmVudCArICgxIDw8IDE0KSkge1xuICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmFkaXhQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZXhwb25lbnQgPiBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCArIDE7XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ID49IE1BWF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93Um91bmRpbmcpIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDAgJiYgc2lnbmlmaWNhbnREaWdpdHMgPCBuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXRzU3RyaW5nID0gZGlnaXRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlnaXRzU3RyaW5nLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUFYO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCArIDEgPCBzaWduaWZpY2FudERpZ2l0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRPZlN0cmluZyA9IG5EaWdpdHNSZWFkO1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZlN0cmluZyA9IGVuZE9mU3RyaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhd1NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGxldCByb3VuZEJpdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgPj0gNSkge1xuICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IGRpZ2l0c1tsYXN0RGlnaXRdICUgMiA9PT0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDI7IGkgPCBlbmRPZlN0cmluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ldLCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRCaXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkSWR4ID0gbGFzdERpZ2l0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZElkeCA+PSAwOyBkSWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2RpZ2l0c1tkSWR4XSA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkSWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdleHBvbmVudCB1bmRlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltuRGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldICE9PSAnMCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHNbbGFzdERpZ2l0XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ICsgMSA8IHNpZ25pZmljYW50RGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYXdTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdERpZ2l0IDwgMTcpIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQgLSAxNzsgZElkeCsrKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IHNpZ25pZmljYW5kSGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduaWZpY2FuZCA9IG11bHRpcGx5NjR4MihzaWduaWZpY2FuZEhpZ2gsIExvbmcuZnJvbVN0cmluZygnMTAwMDAwMDAwMDAwMDAwMDAwJykpO1xuICAgICAgICBzaWduaWZpY2FuZC5sb3cgPSBzaWduaWZpY2FuZC5sb3cuYWRkKHNpZ25pZmljYW5kTG93KTtcbiAgICAgICAgaWYgKGxlc3NUaGFuKHNpZ25pZmljYW5kLmxvdywgc2lnbmlmaWNhbmRMb3cpKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZC5oaWdoID0gc2lnbmlmaWNhbmQuaGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBiaWFzZWRFeHBvbmVudCA9IGV4cG9uZW50ICsgRVhQT05FTlRfQklBUztcbiAgICAgICAgY29uc3QgZGVjID0geyBsb3c6IExvbmcuZnJvbU51bWJlcigwKSwgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApIH07XG4gICAgICAgIGlmIChzaWduaWZpY2FuZC5oaWdoLnNoaWZ0UmlnaHRVbnNpZ25lZCg0OSkuYW5kKExvbmcuZnJvbU51bWJlcigxKSkuZXF1YWxzKExvbmcuZnJvbU51bWJlcigxKSkpIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKDB4Mykuc2hpZnRMZWZ0KDYxKSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCkuYW5kKExvbmcuZnJvbU51bWJlcigweDNmZmYpLnNoaWZ0TGVmdCg0NykpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3Ioc2lnbmlmaWNhbmQuaGlnaC5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4N2ZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoYmlhc2VkRXhwb25lbnQgJiAweDNmZmYpLnNoaWZ0TGVmdCg0OSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChMb25nLmZyb21OdW1iZXIoMHgxZmZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlYy5sb3cgPSBzaWduaWZpY2FuZC5sb3c7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbVN0cmluZygnOTIyMzM3MjAzNjg1NDc3NTgwOCcpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoMTYpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5sb3cubG93ICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmxvdyA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMubG93LmhpZ2ggJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cuaGlnaCA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5oaWdoLmxvdyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2gubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmhpZ2guaGlnaCAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMjQpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYmlhc2VkX2V4cG9uZW50O1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfZGlnaXRzID0gMDtcbiAgICAgICAgY29uc3Qgc2lnbmlmaWNhbmQgPSBuZXcgQXJyYXkoMzYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRbaV0gPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgaXNfemVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfbXNiO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmQxMjggPSB7IHBhcnRzOiBbMCwgMCwgMCwgMF0gfTtcbiAgICAgICAgbGV0IGosIGs7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFtdO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnl0ZXM7XG4gICAgICAgIGNvbnN0IGxvdyA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBtaWRsID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IG1pZGggPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgaGlnaCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGRlYyA9IHtcbiAgICAgICAgICAgIGxvdzogbmV3IExvbmcobG93LCBtaWRsKSxcbiAgICAgICAgICAgIGhpZ2g6IG5ldyBMb25nKG1pZGgsIGhpZ2gpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWMuaGlnaC5sZXNzVGhhbihMb25nLlpFUk8pKSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbWJpbmF0aW9uID0gKGhpZ2ggPj4gMjYpICYgQ09NQklOQVRJT05fTUFTSztcbiAgICAgICAgaWYgKGNvbWJpbmF0aW9uID4+IDMgPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbiA9PT0gQ09NQklOQVRJT05fSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpICsgJ0luZmluaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbWJpbmF0aW9uID09PSBDT01CSU5BVElPTl9OQU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaWFzZWRfZXhwb25lbnQgPSAoaGlnaCA+PiAxNSkgJiBFWFBPTkVOVF9NQVNLO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX21zYiA9IDB4MDggKyAoKGhpZ2ggPj4gMTQpICYgMHgwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9tc2IgPSAoaGlnaCA+PiAxNCkgJiAweDA3O1xuICAgICAgICAgICAgYmlhc2VkX2V4cG9uZW50ID0gKGhpZ2ggPj4gMTcpICYgRVhQT05FTlRfTUFTSztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvbmVudCA9IGJpYXNlZF9leHBvbmVudCAtIEVYUE9ORU5UX0JJQVM7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID0gKGhpZ2ggJiAweDNmZmYpICsgKChzaWduaWZpY2FuZF9tc2IgJiAweGYpIDw8IDE0KTtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMV0gPSBtaWRoO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9IG1pZGw7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID0gbG93O1xuICAgICAgICBpZiAoc2lnbmlmaWNhbmQxMjgucGFydHNbMF0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzFdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbM10gPT09IDApIHtcbiAgICAgICAgICAgIGlzX3plcm8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMzsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVhc3RfZGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkaXZpZGV1MTI4KHNpZ25pZmljYW5kMTI4KTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZDEyOCA9IHJlc3VsdC5xdW90aWVudDtcbiAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSByZXN1bHQucmVtLmxvdztcbiAgICAgICAgICAgICAgICBpZiAoIWxlYXN0X2RpZ2l0cylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gODsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRbayAqIDkgKyBqXSA9IGxlYXN0X2RpZ2l0cyAlIDEwO1xuICAgICAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSBNYXRoLmZsb29yKGxlYXN0X2RpZ2l0cyAvIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3plcm8pIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IDE7XG4gICAgICAgICAgICBzaWduaWZpY2FuZFtpbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gMzY7XG4gICAgICAgICAgICB3aGlsZSAoIXNpZ25pZmljYW5kW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NpZW50aWZpY19leHBvbmVudCA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDEgKyBleHBvbmVudDtcbiAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPj0gMzQgfHwgc2NpZW50aWZpY19leHBvbmVudCA8PSAtNyB8fCBleHBvbmVudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChzaWduaWZpY2FuZF9kaWdpdHMgPiAzNCkge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAkezB9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID4gMClcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYEUrJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBvbmVudCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGBFJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cykge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnRScpO1xuICAgICAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCske3NjaWVudGlmaWNfZXhwb25lbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzY2llbnRpZmljX2V4cG9uZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByYWRpeF9wb3NpdGlvbiA9IHNpZ25pZmljYW5kX2RpZ2l0cyArIGV4cG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChyYWRpeF9wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWRpeF9wb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJy4nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFkaXhfcG9zaXRpb24rKyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZF9kaWdpdHMgLSBNYXRoLm1heChyYWRpeF9wb3NpdGlvbiAtIDEsIDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguZnJvbVN0cmluZyhkb2MuJG51bWJlckRlY2ltYWwpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBkMTI4c3RyaW5nID0gaW5zcGVjdCh0aGlzLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYG5ldyBEZWNpbWFsMTI4KCR7ZDEyOHN0cmluZ30pYDtcbiAgICB9XG59XG5cbmNsYXNzIERvdWJsZSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEb3VibGUnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSArdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ05hTicpXG4gICAgICAgICAgICByZXR1cm4gbmV3IERvdWJsZShOYU4pO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdJbmZpbml0eScpXG4gICAgICAgICAgICByZXR1cm4gbmV3IERvdWJsZShJbmZpbml0eSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJy1JbmZpbml0eScpXG4gICAgICAgICAgICByZXR1cm4gbmV3IERvdWJsZSgtSW5maW5pdHkpO1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjb2VyY2VkVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBJbnB1dDogJHt2YWx1ZX0gaXMgbm90IHJlcHJlc2VudGFibGUgYXMgYSBEb3VibGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHJpbSgpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgSW5wdXQ6ICcke3ZhbHVlfScgY29udGFpbnMgd2hpdGVzcGFjZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYElucHV0IGlzIGFuIGVtcHR5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvW14tMC05LitlRV0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBJbnB1dDogJyR7dmFsdWV9JyBpcyBub3QgaW4gZGVjaW1hbCBvciBleHBvbmVudGlhbCBub3RhdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRG91YmxlKGNvZXJjZWRWYWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubGVnYWN5IHx8IChvcHRpb25zLnJlbGF4ZWQgJiYgaXNGaW5pdGUodGhpcy52YWx1ZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pcyhNYXRoLnNpZ24odGhpcy52YWx1ZSksIC0wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogJy0wLjAnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRudW1iZXJEb3VibGU6IE51bWJlci5pc0ludGVnZXIodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLnRvRml4ZWQoMSkgOiB0aGlzLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdChkb2MuJG51bWJlckRvdWJsZSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IGRvdWJsZVZhbHVlIDogbmV3IERvdWJsZShkb3VibGVWYWx1ZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IERvdWJsZSgke2luc3BlY3QodGhpcy52YWx1ZSwgb3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBJbnQzMiBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdJbnQzMic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9ICt2YWx1ZSB8IDA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRWYWx1ZSA9IHJlbW92ZUxlYWRpbmdaZXJvc0FuZEV4cGxpY2l0UGx1cyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChCU09OX0lOVDMyX01BWCA8IGNvZXJjZWRWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgSW5wdXQ6ICcke3ZhbHVlfScgaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgZm9yIEludDMyYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlNPTl9JTlQzMl9NSU4gPiBjb2VyY2VkVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYElucHV0OiAnJHt2YWx1ZX0nIGlzIHNtYWxsZXIgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSBmb3IgSW50MzJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29lcmNlZFZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgSW5wdXQ6ICcke3ZhbHVlfScgaXMgbm90IGEgc2FmZSBpbnRlZ2VyYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFZhbHVlLnRvU3RyaW5nKCkgIT09IGNsZWFuZWRWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgSW5wdXQ6ICcke3ZhbHVlfScgaXMgbm90IGEgdmFsaWQgSW50MzIgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMihjb2VyY2VkVmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcocmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnJlbGF4ZWQgfHwgb3B0aW9ucy5sZWdhY3kpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJJbnQ6IHRoaXMudmFsdWUudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkID8gcGFyc2VJbnQoZG9jLiRudW1iZXJJbnQsIDEwKSA6IG5ldyBJbnQzMihkb2MuJG51bWJlckludCk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IEludDMyKCR7aW5zcGVjdCh0aGlzLnZhbHVlLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIE1heEtleSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdNYXhLZXknO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG1heEtleTogMSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhLZXkoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuICduZXcgTWF4S2V5KCknO1xuICAgIH1cbn1cblxuY2xhc3MgTWluS2V5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ01pbktleSc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbWluS2V5OiAxIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1pbktleSgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gJ25ldyBNaW5LZXkoKSc7XG4gICAgfVxufVxuXG5sZXQgUFJPQ0VTU19VTklRVUUgPSBudWxsO1xuY29uc3QgX19pZENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIE9iamVjdElkIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ09iamVjdElkJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXRJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBsZXQgd29ya2luZ0lkO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQgPT09ICdvYmplY3QnICYmIGlucHV0SWQgJiYgJ2lkJyBpbiBpbnB1dElkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQuaWQgIT09ICdzdHJpbmcnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXRJZC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gbXVzdCBoYXZlIGFuIGlkIHRoYXQgaXMgb2YgdHlwZSBzdHJpbmcgb3IgQnVmZmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3RvSGV4U3RyaW5nJyBpbiBpbnB1dElkICYmIHR5cGVvZiBpbnB1dElkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd29ya2luZ0lkID0gQnl0ZVV0aWxzLmZyb21IZXgoaW5wdXRJZC50b0hleFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtpbmdJZCA9IGlucHV0SWQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3b3JraW5nSWQgPSBpbnB1dElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JraW5nSWQgPT0gbnVsbCB8fCB0eXBlb2Ygd29ya2luZ0lkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBPYmplY3RJZC5nZW5lcmF0ZSh0eXBlb2Ygd29ya2luZ0lkID09PSAnbnVtYmVyJyA/IHdvcmtpbmdJZCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHdvcmtpbmdJZCkgJiYgd29ya2luZ0lkLmJ5dGVMZW5ndGggPT09IDEyKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZSh3b3JraW5nSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3b3JraW5nSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0SWQudmFsaWRhdGVIZXhTdHJpbmcod29ya2luZ0lkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLmZyb21IZXgod29ya2luZ0lkKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX19pZENhY2hlLnNldCh0aGlzLCB3b3JraW5nSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lucHV0IG11c3QgYmUgYSAyNCBjaGFyYWN0ZXIgaGV4IHN0cmluZywgMTIgYnl0ZSBVaW50OEFycmF5LCBvciBhbiBpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gZG9lcyBub3QgbWF0Y2ggdGhlIGFjY2VwdGVkIHR5cGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIF9faWRDYWNoZS5zZXQodGhpcywgQnl0ZVV0aWxzLnRvSGV4KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHZhbGlkYXRlSGV4U3RyaW5nKHN0cmluZykge1xuICAgICAgICBpZiAoc3RyaW5nPy5sZW5ndGggIT09IDI0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY2hhciA+PSA0OCAmJiBjaGFyIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgIChjaGFyID49IDk3ICYmIGNoYXIgPD0gMTAyKSB8fFxuICAgICAgICAgICAgICAgIChjaGFyID49IDY1ICYmIGNoYXIgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IF9faWQgPSBfX2lkQ2FjaGUuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKF9faWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9faWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4U3RyaW5nID0gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIF9faWRDYWNoZS5zZXQodGhpcywgaGV4U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4U3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5jKCkge1xuICAgICAgICByZXR1cm4gKE9iamVjdElkLmluZGV4ID0gKE9iamVjdElkLmluZGV4ICsgMSkgJSAweGZmZmZmZik7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSh0aW1lKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmMgPSBPYmplY3RJZC5nZXRJbmMoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKDEyKTtcbiAgICAgICAgTnVtYmVyVXRpbHMuc2V0SW50MzJCRShidWZmZXIsIDAsIHRpbWUpO1xuICAgICAgICBpZiAoUFJPQ0VTU19VTklRVUUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFBST0NFU1NfVU5JUVVFID0gQnl0ZVV0aWxzLnJhbmRvbUJ5dGVzKDUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcls0XSA9IFBST0NFU1NfVU5JUVVFWzBdO1xuICAgICAgICBidWZmZXJbNV0gPSBQUk9DRVNTX1VOSVFVRVsxXTtcbiAgICAgICAgYnVmZmVyWzZdID0gUFJPQ0VTU19VTklRVUVbMl07XG4gICAgICAgIGJ1ZmZlcls3XSA9IFBST0NFU1NfVU5JUVVFWzNdO1xuICAgICAgICBidWZmZXJbOF0gPSBQUk9DRVNTX1VOSVFVRVs0XTtcbiAgICAgICAgYnVmZmVyWzExXSA9IGluYyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlclsxMF0gPSAoaW5jID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyWzldID0gKGluYyA+PiAxNikgJiAweGZmO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4JylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzKHZhcmlhYmxlKSB7XG4gICAgICAgIHJldHVybiAodmFyaWFibGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhYmxlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ19ic29udHlwZScgaW4gdmFyaWFibGUgJiZcbiAgICAgICAgICAgIHZhcmlhYmxlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcklkKSB7XG4gICAgICAgIGlmIChvdGhlcklkID09PSB1bmRlZmluZWQgfHwgb3RoZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3RJZC5pcyhvdGhlcklkKSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmJ1ZmZlclsxMV0gPT09IG90aGVySWQuYnVmZmVyWzExXSAmJiBCeXRlVXRpbHMuZXF1YWxzKHRoaXMuYnVmZmVyLCBvdGhlcklkLmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcklkLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvdGhlcklkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcklkU3RyaW5nID0gb3RoZXJJZC50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlcklkU3RyaW5nID09PSAnc3RyaW5nJyAmJiBvdGhlcklkU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IHRoaXNJZFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZSA9IE51bWJlclV0aWxzLmdldFVpbnQzMkJFKHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgdGltZXN0YW1wLnNldFRpbWUoTWF0aC5mbG9vcih0aW1lKSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUGsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gICAgc2VyaWFsaXplSW50byh1aW50OGFycmF5LCBpbmRleCkge1xuICAgICAgICB1aW50OGFycmF5W2luZGV4XSA9IHRoaXMuYnVmZmVyWzBdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlclsxXTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDJdID0gdGhpcy5idWZmZXJbMl07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyWzNdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgNF0gPSB0aGlzLmJ1ZmZlcls0XTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDVdID0gdGhpcy5idWZmZXJbNV07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyA2XSA9IHRoaXMuYnVmZmVyWzZdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgN10gPSB0aGlzLmJ1ZmZlcls3XTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDhdID0gdGhpcy5idWZmZXJbOF07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyA5XSA9IHRoaXMuYnVmZmVyWzldO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMTBdID0gdGhpcy5idWZmZXJbMTBdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMTFdID0gdGhpcy5idWZmZXJbMTFdO1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tVGltZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAxMTsgaSA+PSA0OyBpLS0pXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICBOdW1iZXJVdGlscy5zZXRJbnQzMkJFKGJ1ZmZlciwgMCwgdGltZSk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21IZXhTdHJpbmcoaGV4U3RyaW5nKSB7XG4gICAgICAgIGlmIChoZXhTdHJpbmc/Lmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2hleCBzdHJpbmcgbXVzdCBiZSAyNCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUhleChoZXhTdHJpbmcpKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIGlmIChiYXNlNjQ/Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2Jhc2U2NCBzdHJpbmcgbXVzdCBiZSAxNiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoaWQpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdElkLnZhbGlkYXRlSGV4U3RyaW5nKGlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBPYmplY3RJZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLnRvSGV4U3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHsgJG9pZDogdGhpcy50b0hleFN0cmluZygpIH07XG4gICAgICAgIHJldHVybiB7ICRvaWQ6IHRoaXMudG9TdHJpbmcoJ2hleCcpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGRvYy4kb2lkKTtcbiAgICB9XG4gICAgaXNDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5jYWNoZUhleFN0cmluZyAmJiBfX2lkQ2FjaGUuaGFzKHRoaXMpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBPYmplY3RJZCgke2luc3BlY3QodGhpcy50b0hleFN0cmluZygpLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5PYmplY3RJZC5pbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmKTtcblxuZnVuY3Rpb24gaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKG9iamVjdCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpIHtcbiAgICBsZXQgdG90YWxMZW5ndGggPSA0ICsgMTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGkudG9TdHJpbmcoKSwgb2JqZWN0W2ldLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGtleSwgb2JqZWN0W2tleV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudChuYW1lLCB2YWx1ZSwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlzQXJyYXkgPSBmYWxzZSwgaWdub3JlVW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAxICsgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSArIDQgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUpICsgMTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA+PSBKU19JTlRfTUlOICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPD0gSlNfSU5UX01BWCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDMyX01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoOCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkgfHwgIWlnbm9yZVVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICgxICsgMSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbQlNPTl9WRVJTSU9OX1NZTUJPTF0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMSArIDQgKyAxKSArIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMTYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNjb3BlICE9IG51bGwgJiYgT2JqZWN0LmtleXModmFsdWUuc2NvcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5jb2RlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLnNjb3BlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmFyeS5wb3NpdGlvbiArIDEgKyA0ICsgMSArIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdTeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkX3ZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuICAgICAgICAgICAgICAgIH0sIHZhbHVlLmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZF92YWx1ZXNbJyRkYiddID0gdmFsdWUuZGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob3JkZXJlZF92YWx1ZXMsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmdsb2JhbCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pZ25vcmVDYXNlID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLm11bHRpbGluZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnBhdHRlcm4pICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5vcHRpb25zKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhbHBoYWJldGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJyk7XG59XG5jbGFzcyBCU09OUmVnRXhwIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05SZWdFeHAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFscGhhYmV0aXplKG9wdGlvbnMgPz8gJycpO1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIFJlZ2V4IHBhdHRlcm5zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGF0dGVybil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBvcHRpb25zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9uc1tpXSA9PT0gJ2knIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAnbScgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd4JyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ2wnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAncycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd1JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBUaGUgcmVndWxhciBleHByZXNzaW9uIG9wdGlvbiBbJHt0aGlzLm9wdGlvbnNbaV19XSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gb3B0aW9ucy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJHJlZ2V4OiB0aGlzLnBhdHRlcm4sICRvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkcmVndWxhckV4cHJlc3Npb246IHsgcGF0dGVybjogdGhpcy5wYXR0ZXJuLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgaWYgKCckcmVnZXgnIGluIGRvYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJHJlZ2V4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChkb2MuJHJlZ2V4Ll9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCU09OUmVnRXhwKGRvYy4kcmVnZXgsIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgnJHJlZ3VsYXJFeHByZXNzaW9uJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLnBhdHRlcm4sIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kcmVndWxhckV4cHJlc3Npb24ub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVuZXhwZWN0ZWQgQlNPTlJlZ0V4cCBFSlNPTiBvYmplY3QgZm9ybTogJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxpemUgPSBnZXRTdHlsaXplRnVuY3Rpb24ob3B0aW9ucykgPz8gKHYgPT4gdik7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gc3R5bGl6ZShpbnNwZWN0KHRoaXMucGF0dGVybiksICdyZWdleHAnKTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBzdHlsaXplKGluc3BlY3QodGhpcy5vcHRpb25zKSwgJ3JlZ2V4cCcpO1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OUmVnRXhwKCR7cGF0dGVybn0sICR7ZmxhZ3N9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OU3ltYm9sIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05TeW1ib2wnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkc3ltYm9sOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEJTT05TeW1ib2woZG9jLiRzeW1ib2wpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OU3ltYm9sKCR7aW5zcGVjdCh0aGlzLnZhbHVlLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNvbnN0IExvbmdXaXRob3V0T3ZlcnJpZGVzQ2xhc3MgPSBMb25nO1xuY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgTG9uZ1dpdGhvdXRPdmVycmlkZXNDbGFzcyB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICAgIH1cbiAgICBnZXQgaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICAgIH1cbiAgICBnZXQgdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG93KSB7XG4gICAgICAgIGlmIChsb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3VwZXIoMCwgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHN1cGVyKGxvdywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTG9uZy5pc0xvbmcobG93KSkge1xuICAgICAgICAgICAgc3VwZXIobG93LmxvdywgbG93LmhpZ2gsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3cgPT09ICdvYmplY3QnICYmICd0JyBpbiBsb3cgJiYgJ2knIGluIGxvdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb3cudCAhPT0gJ251bWJlcicgJiYgKHR5cGVvZiBsb3cudCAhPT0gJ29iamVjdCcgfHwgbG93LnQuX2Jzb250eXBlICE9PSAnSW50MzInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSB0IGFzIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvdy5pICE9PSAnbnVtYmVyJyAmJiAodHlwZW9mIGxvdy5pICE9PSAnb2JqZWN0JyB8fCBsb3cuaS5fYnNvbnR5cGUgIT09ICdJbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGkgYXMgYSBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBOdW1iZXIobG93LnQpO1xuICAgICAgICAgICAgY29uc3QgaSA9IE51bWJlcihsb3cuaSk7XG4gICAgICAgICAgICBpZiAodCA8IDAgfHwgTnVtYmVyLmlzTmFOKHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGEgcG9zaXRpdmUgdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IE51bWJlci5pc05hTihpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBhIHBvc2l0aXZlIGknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ID4gMHhmZmZmX2ZmZmYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgdCBlcXVhbCBvciBsZXNzIHRoYW4gdWludDMyIG1heCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAweGZmZmZfZmZmZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBpIGVxdWFsIG9yIGxlc3MgdGhhbiB1aW50MzIgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlcihpLCB0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0EgVGltZXN0YW1wIGNhbiBvbmx5IGJlIGNvbnN0cnVjdGVkIHdpdGg6IGJpZ2ludCwgTG9uZywgb3IgeyB0OiBudW1iZXI7IGk6IG51bWJlciB9Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHRpbWVzdGFtcDogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbUludCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21OdW1iZXIodmFsdWUsIHRydWUpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHsgaTogbG93Qml0cywgdDogaGlnaEJpdHMgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgb3B0UmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tU3RyaW5nKHN0ciwgdHJ1ZSwgb3B0UmFkaXgpKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICR0aW1lc3RhbXA6IHsgdDogdGhpcy50LCBpOiB0aGlzLmkgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgY29uc3QgaSA9IExvbmcuaXNMb25nKGRvYy4kdGltZXN0YW1wLmkpXG4gICAgICAgICAgICA/IGRvYy4kdGltZXN0YW1wLmkuZ2V0TG93Qml0c1Vuc2lnbmVkKClcbiAgICAgICAgICAgIDogZG9jLiR0aW1lc3RhbXAuaTtcbiAgICAgICAgY29uc3QgdCA9IExvbmcuaXNMb25nKGRvYy4kdGltZXN0YW1wLnQpXG4gICAgICAgICAgICA/IGRvYy4kdGltZXN0YW1wLnQuZ2V0TG93Qml0c1Vuc2lnbmVkKClcbiAgICAgICAgICAgIDogZG9jLiR0aW1lc3RhbXAudDtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoeyB0LCBpIH0pO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCB0ID0gaW5zcGVjdCh0aGlzLnQsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpID0gaW5zcGVjdCh0aGlzLmksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYG5ldyBUaW1lc3RhbXAoeyB0OiAke3R9LCBpOiAke2l9IH0pYDtcbiAgICB9XG59XG5UaW1lc3RhbXAuTUFYX1ZBTFVFID0gTG9uZy5NQVhfVU5TSUdORURfVkFMVUU7XG5cbmNvbnN0IEpTX0lOVF9NQVhfTE9ORyA9IExvbmcuZnJvbU51bWJlcihKU19JTlRfTUFYKTtcbmNvbnN0IEpTX0lOVF9NSU5fTE9ORyA9IExvbmcuZnJvbU51bWJlcihKU19JTlRfTUlOKTtcbmZ1bmN0aW9uIGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyLCBvcHRpb25zLCBpc0FycmF5KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogb3B0aW9ucztcbiAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleCA/IG9wdGlvbnMuaW5kZXggOiAwO1xuICAgIGNvbnN0IHNpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgIGlmIChzaXplIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBic29uIHNpemUgbXVzdCBiZSA+PSA1LCBpcyAke3NpemV9YCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplICYmIGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGJ1ZmZlciBsZW5ndGggJHtidWZmZXIubGVuZ3RofSBtdXN0IGJlID49IGJzb24gc2l6ZSAke3NpemV9YCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGJ1ZmZlciBsZW5ndGggJHtidWZmZXIubGVuZ3RofSBtdXN0ID09PSBic29uIHNpemUgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAoc2l6ZSArIGluZGV4ID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgKGJzb24gc2l6ZSAke3NpemV9ICsgb3B0aW9ucy5pbmRleCAke2luZGV4fSBtdXN0IGJlIDw9IGJ1ZmZlciBsZW5ndGggJHtidWZmZXIuYnl0ZUxlbmd0aH0pYCk7XG4gICAgfVxuICAgIGlmIChidWZmZXJbaW5kZXggKyBzaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihcIk9uZSBvYmplY3QsIHNpemVkIGNvcnJlY3RseSwgd2l0aCBhIHNwb3QgZm9yIGFuIEVPTywgYnV0IHRoZSBFT08gaXNuJ3QgMHgwMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkpO1xufVxuY29uc3QgYWxsb3dlZERCUmVmS2V5cyA9IC9eXFwkcmVmJHxeXFwkaWQkfF5cXCRkYiQvO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBpbmRleCwgb3B0aW9ucywgaXNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZmllbGRzQXNSYXcgPSBvcHRpb25zWydmaWVsZHNBc1JhdyddID09IG51bGwgPyBudWxsIDogb3B0aW9uc1snZmllbGRzQXNSYXcnXTtcbiAgICBjb25zdCByYXcgPSBvcHRpb25zWydyYXcnXSA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zWydyYXcnXTtcbiAgICBjb25zdCBic29uUmVnRXhwID0gdHlwZW9mIG9wdGlvbnNbJ2Jzb25SZWdFeHAnXSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9uc1snYnNvblJlZ0V4cCddIDogZmFsc2U7XG4gICAgY29uc3QgcHJvbW90ZUJ1ZmZlcnMgPSBvcHRpb25zLnByb21vdGVCdWZmZXJzID8/IGZhbHNlO1xuICAgIGNvbnN0IHByb21vdGVMb25ncyA9IG9wdGlvbnMucHJvbW90ZUxvbmdzID8/IHRydWU7XG4gICAgY29uc3QgcHJvbW90ZVZhbHVlcyA9IG9wdGlvbnMucHJvbW90ZVZhbHVlcyA/PyB0cnVlO1xuICAgIGNvbnN0IHVzZUJpZ0ludDY0ID0gb3B0aW9ucy51c2VCaWdJbnQ2NCA/PyBmYWxzZTtcbiAgICBpZiAodXNlQmlnSW50NjQgJiYgIXByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTXVzdCBlaXRoZXIgcmVxdWVzdCBiaWdpbnQgb3IgTG9uZyBmb3IgaW50NjQgZGVzZXJpYWxpemF0aW9uJyk7XG4gICAgfVxuICAgIGlmICh1c2VCaWdJbnQ2NCAmJiAhcHJvbW90ZUxvbmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ011c3QgZWl0aGVyIHJlcXVlc3QgYmlnaW50IG9yIExvbmcgZm9yIGludDY0IGRlc2VyaWFsaXphdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uID0gb3B0aW9ucy52YWxpZGF0aW9uID09IG51bGwgPyB7IHV0Zjg6IHRydWUgfSA6IG9wdGlvbnMudmFsaWRhdGlvbjtcbiAgICBsZXQgZ2xvYmFsVVRGVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgbGV0IHZhbGlkYXRpb25TZXR0aW5nO1xuICAgIGxldCB1dGY4S2V5c1NldDtcbiAgICBjb25zdCB1dGY4VmFsaWRhdGVkS2V5cyA9IHZhbGlkYXRpb24udXRmODtcbiAgICBpZiAodHlwZW9mIHV0ZjhWYWxpZGF0ZWRLZXlzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGVkS2V5cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFVURlZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdXRmOFZhbGlkYXRpb25WYWx1ZXMgPSBPYmplY3Qua2V5cyh1dGY4VmFsaWRhdGVkS2V5cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGY4VmFsaWRhdGVkS2V5c1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHV0ZjhWYWxpZGF0aW9uVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVVRGLTggdmFsaWRhdGlvbiBzZXR0aW5nIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXRmOFZhbGlkYXRpb25WYWx1ZXNbMF0gIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiwgbXVzdCBzcGVjaWZ5IGJvb2xlYW4gdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGlvblZhbHVlc1swXTtcbiAgICAgICAgaWYgKCF1dGY4VmFsaWRhdGlvblZhbHVlcy5ldmVyeShpdGVtID0+IGl0ZW0gPT09IHZhbGlkYXRpb25TZXR0aW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiAtIGtleXMgbXVzdCBiZSBhbGwgdHJ1ZSBvciBhbGwgZmFsc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgdXRmOEtleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHV0ZjhWYWxpZGF0ZWRLZXlzKSkge1xuICAgICAgICAgICAgdXRmOEtleXNTZXQuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgNSlcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBic29uIG1lc3NhZ2UgPCA1IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICBpbmRleCArPSA0O1xuICAgIGlmIChzaXplIDwgNSB8fCBzaXplID4gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBic29uIG1lc3NhZ2UnKTtcbiAgICBjb25zdCBvYmplY3QgPSBpc0FycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgYXJyYXlJbmRleCA9IDA7XG4gICAgY29uc3QgZG9uZSA9IGZhbHNlO1xuICAgIGxldCBpc1Bvc3NpYmxlREJSZWYgPSBpc0FycmF5ID8gZmFsc2UgOiBudWxsO1xuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGJ1ZmZlcltpbmRleCsrXTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBpID0gaW5kZXg7XG4gICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGlzQXJyYXkgPyBhcnJheUluZGV4KysgOiBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgbGV0IHNob3VsZFZhbGlkYXRlS2V5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdsb2JhbFVURlZhbGlkYXRpb24gfHwgdXRmOEtleXNTZXQ/LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGVLZXkgPSB2YWxpZGF0aW9uU2V0dGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlS2V5ID0gIXZhbGlkYXRpb25TZXR0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Bvc3NpYmxlREJSZWYgIT09IGZhbHNlICYmIG5hbWVbMF0gPT09ICckJykge1xuICAgICAgICAgICAgaXNQb3NzaWJsZURCUmVmID0gYWxsb3dlZERCUmVmS2V5cy50ZXN0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfU1RSSU5HKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX09JRCkge1xuICAgICAgICAgICAgY29uc3Qgb2lkID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKDEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgICAgICAgICBvaWRbaV0gPSBidWZmZXJbaW5kZXggKyBpXTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE9iamVjdElkKG9pZCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9JTlQgJiYgcHJvbW90ZVZhbHVlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEludDMyKE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX05VTUJFUikge1xuICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXJVdGlscy5nZXRGbG9hdDY0TEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgaWYgKHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERvdWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9EQVRFKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dCaXRzID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hCaXRzID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4ICsgNCk7XG4gICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cykudG9OdW1iZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9CT09MRUFOKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2luZGV4XSAhPT0gMCAmJiBidWZmZXJbaW5kZXhdICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lsbGVnYWwgYm9vbGVhbiB0eXBlIHZhbHVlJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlcltpbmRleCsrXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX09CSkVDVCkge1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvYmplY3RTaXplIDw9IDAgfHwgb2JqZWN0U2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgZW1iZWRkZWQgZG9jdW1lbnQgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyBvYmplY3RTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBvYmplY3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdmFsaWRhdGlvbjogeyB1dGY4OiBzaG91bGRWYWxpZGF0ZUtleSB9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIG9iamVjdE9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQVJSQVkpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBsZXQgYXJyYXlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHN0b3BJbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmIChmaWVsZHNBc1JhdyAmJiBmaWVsZHNBc1Jhd1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnMgPSB7IC4uLmFycmF5T3B0aW9ucywgdmFsaWRhdGlvbjogeyB1dGY4OiBzaG91bGRWYWxpZGF0ZUtleSB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBhcnJheU9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2luZGV4IC0gMV0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW52YWxpZCBhcnJheSB0ZXJtaW5hdG9yIGJ5dGUnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc3RvcEluZGV4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHRlZCBhcnJheSBic29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9VTkRFRklORUQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVMTCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTE9ORykge1xuICAgICAgICAgICAgaWYgKHVzZUJpZ0ludDY0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXJVdGlscy5nZXRCaWdJbnQ2NExFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb3dCaXRzID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoQml0cyA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCArIDQpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9uZyA9IG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbW90ZUxvbmdzICYmIHByb21vdGVWYWx1ZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZy5sZXNzVGhhbk9yRXF1YWwoSlNfSU5UX01BWF9MT05HKSAmJiBsb25nLmdyZWF0ZXJUaGFuT3JFcXVhbChKU19JTlRfTUlOX0xPTkcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb25nLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREVDSU1BTDEyOCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoMTYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYnVmZmVyW2luZGV4ICsgaV07XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTY7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsMTI4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0JJTkFSWSkge1xuICAgICAgICAgICAgbGV0IGJpbmFyeVNpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQmluYXJ5U2l6ZSA9IGJpbmFyeVNpemU7XG4gICAgICAgICAgICBjb25zdCBzdWJUeXBlID0gYnVmZmVyW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCcpO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSBzaXplIGxhcmdlciB0aGFuIGRvY3VtZW50IHNpemUnKTtcbiAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgYmluYXJ5U2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCBmb3Igc3VidHlwZSAweDAyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gbG9uZyBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIHNob3J0IGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbW90ZUJ1ZmZlcnMgJiYgcHJvbW90ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBCaW5hcnkoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpLCBzdWJUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyAmJiBVVUlELmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VVUlEKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIGJpbmFyeVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zQXJyYXkgPSBuZXcgQXJyYXkocmVnRXhwT3B0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlZ0V4cE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZ0V4cE9wdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnaSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAoc291cmNlLCBvcHRpb25zQXJyYXkuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfUkVHRVhQICYmIGJzb25SZWdFeHAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBCU09OUmVnRXhwKHNvdXJjZSwgcmVnRXhwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9TWU1CT0wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb21vdGVWYWx1ZXMgPyBzeW1ib2wgOiBuZXcgQlNPTlN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9USU1FU1RBTVApIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFRpbWVzdGFtcCh7XG4gICAgICAgICAgICAgICAgaTogTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoYnVmZmVyLCBpbmRleCksXG4gICAgICAgICAgICAgICAgdDogTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoYnVmZmVyLCBpbmRleCArIDQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9NSU5fS0VZKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBNaW5LZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX01BWF9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1heEtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQ09ERSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29kZShmdW5jdGlvblN0cmluZyk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0NPREVfV19TQ09QRSkge1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICBpZiAodG90YWxTaXplIDwgNCArIDQgKyA0ICsgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIHNob3J0ZXIgbWluaW11bSBleHBlY3RlZCBsZW5ndGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZSA8IDQgKyA0ICsgb2JqZWN0U2l6ZSArIHN0cmluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBpcyB0b28gc2hvcnQsIHRydW5jYXRpbmcgc2NvcGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPiA0ICsgNCArIG9iamVjdFNpemUgKyBzdHJpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgaXMgdG9vIGxvbmcsIGNsaXBzIG91dGVyIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb2RlKGZ1bmN0aW9uU3RyaW5nLCBzY29wZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9EQlBPSU5URVIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgICAgICBjb25zdCBvaWRCdWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoMTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICAgICAgICAgIG9pZEJ1ZmZlcltpXSA9IGJ1ZmZlcltpbmRleCArIGldO1xuICAgICAgICAgICAgY29uc3Qgb2lkID0gbmV3IE9iamVjdElkKG9pZEJ1ZmZlcik7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEQlJlZihuYW1lc3BhY2UsIG9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBEZXRlY3RlZCB1bmtub3duIEJTT04gdHlwZSAke2VsZW1lbnRUeXBlLnRvU3RyaW5nKDE2KX0gZm9yIGZpZWxkbmFtZSBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBpbmRleCAtIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGFycmF5IGJzb24nKTtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBvYmplY3QgYnNvbicpO1xuICAgIH1cbiAgICBpZiAoIWlzUG9zc2libGVEQlJlZilcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBpZiAoaXNEQlJlZkxpa2Uob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYob2JqZWN0LiRyZWYsIG9iamVjdC4kaWQsIG9iamVjdC4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG5jb25zdCByZWdleHAgPSAvXFx4MDAvO1xuY29uc3QgaWdub3JlS2V5cyA9IG5ldyBTZXQoWyckZGInLCAnJHJlZicsICckaWQnLCAnJGNsdXN0ZXJUaW1lJ10pO1xuZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfU1RSSU5HO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzICsgMTtcbiAgICBidWZmZXJbaW5kZXggLSAxXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLCBpbmRleCArIDQpO1xuICAgIE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSArIDEpO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBPYmplY3QuaXModmFsdWUsIC0wKTtcbiAgICBjb25zdCB0eXBlID0gIWlzTmVnYXRpdmVaZXJvICYmXG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJlxuICAgICAgICB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTlxuICAgICAgICA/IEJTT05fREFUQV9JTlRcbiAgICAgICAgOiBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHR5cGU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEZsb2F0NjRMRShidWZmZXIsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0xPTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCArPSBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEJpZ0ludDY0TEUoYnVmZmVyLCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIF8sIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQk9PTEVBTjtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlID8gMSA6IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RBVEU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBkYXRlSW5NaWxpcyA9IExvbmcuZnJvbU51bWJlcih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIGNvbnN0IGxvd0JpdHMgPSBkYXRlSW5NaWxpcy5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSBkYXRlSW5NaWxpcy5nZXRIaWdoQml0cygpO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgbG93Qml0cyk7XG4gICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBoaWdoQml0cyk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2UubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3ZhbHVlICcgKyB2YWx1ZS5zb3VyY2UgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUuc291cmNlLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodmFsdWUuaWdub3JlQ2FzZSlcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg2OTtcbiAgICBpZiAodmFsdWUuZ2xvYmFsKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDczO1xuICAgIGlmICh2YWx1ZS5tdWx0aWxpbmUpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4NmQ7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnBhdHRlcm4ubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3BhdHRlcm4gJyArIHZhbHVlLnBhdHRlcm4gKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUucGF0dGVybiwgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc29ydGVkT3B0aW9ucyA9IHZhbHVlLm9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKTtcbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc29ydGVkT3B0aW9ucywgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX01JTl9LRVk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTUFYX0tFWTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09JRDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGluZGV4ICs9IHZhbHVlLnNlcmlhbGl6ZUludG8oYnVmZmVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHNpemUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICBpZiAoc2l6ZSA8PSAxNikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIGldID0gdmFsdWVbaV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgfVxuICAgIGluZGV4ID0gaW5kZXggKyBzaXplO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEJTT04nKTtcbiAgICB9XG4gICAgcGF0aC5hZGQodmFsdWUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQlNPTl9EQVRBX0FSUkFZIDogQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICBwYXRoLmRlbGV0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RFQ0lNQUwxMjg7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIGJ1ZmZlcltpbmRleCArIGldID0gdmFsdWUuYnl0ZXNbaV07XG4gICAgcmV0dXJuIGluZGV4ICsgMTY7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPVxuICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyA/IEJTT05fREFUQV9MT05HIDogQlNPTl9EQVRBX1RJTUVTVEFNUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGxvd0JpdHMgPSB2YWx1ZS5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSB2YWx1ZS5nZXRIaWdoQml0cygpO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgbG93Qml0cyk7XG4gICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBoaWdoQml0cyk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9JTlQ7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVU1CRVI7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRGbG9hdDY0TEUoYnVmZmVyLCBpbmRleCwgdmFsdWUudmFsdWUpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgIE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSk7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzID0gZmFsc2UsIGRlcHRoID0gMCwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCA9IHRydWUsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUuc2NvcGUgJiYgdHlwZW9mIHZhbHVlLnNjb3BlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQ7XG4gICAgICAgIGNvbnN0IGNvZGVTaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIGNvZGVTaXplKTtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgNCArIGNvZGVTaXplIC0gMV0gPSAwO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgY29kZVNpemUgKyA0O1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCB2YWx1ZS5zY29wZSwgY2hlY2tLZXlzLCBpbmRleCwgZGVwdGggKyAxLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgIGluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgIHN0YXJ0SW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIHN0YXJ0SW5kZXgsIHRvdGFsU2l6ZSk7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBzaXplKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHZhbHVlLnBvc2l0aW9uO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSlcbiAgICAgICAgc2l6ZSA9IHNpemUgKyA0O1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgaWYgKHZhbHVlLnN1Yl90eXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgIHNpemUgPSBzaXplIC0gNDtcbiAgICAgICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBzaXplKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnN1Yl90eXBlID09PSBCaW5hcnkuU1VCVFlQRV9WRUNUT1IpIHtcbiAgICAgICAgdmFsaWRhdGVCaW5hcnlWZWN0b3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8PSAxNikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIGldID0gZGF0YVtpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5zZXQoZGF0YSwgaW5kZXgpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgdmFsdWUucG9zaXRpb247XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfU1lNQk9MO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLnZhbHVlLCBpbmRleCArIDQpICsgMTtcbiAgICBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHNpemUpO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgbGV0IG91dHB1dCA9IHtcbiAgICAgICAgJHJlZjogdmFsdWUuY29sbGVjdGlvbiB8fCB2YWx1ZS5uYW1lc3BhY2UsXG4gICAgICAgICRpZDogdmFsdWUub2lkXG4gICAgfTtcbiAgICBpZiAodmFsdWUuZGIgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQuJGRiID0gdmFsdWUuZGI7XG4gICAgfVxuICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24ob3V0cHV0LCB2YWx1ZS5maWVsZHMpO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG91dHB1dCwgZmFsc2UsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgcGF0aCk7XG4gICAgY29uc3Qgc2l6ZSA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICBzdGFydEluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCBzdGFydGluZ0luZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmZmVyWzBdID0gMHgwNTtcbiAgICAgICAgICAgIGJ1ZmZlclsxXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbMl0gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzNdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlcls0XSA9IDB4MDA7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdzZXJpYWxpemUgZG9lcyBub3Qgc3VwcG9ydCBhbiBhcnJheSBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignc2VyaWFsaXplIGRvZXMgbm90IHN1cHBvcnQgbm9uLW9iamVjdCBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdfYnNvbnR5cGUnIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0Ll9ic29udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gdHlwZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYXMgYSBkb2N1bWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1JlZ0V4cChvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1VpbnQ4QXJyYXkob2JqZWN0KSB8fFxuICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBkYXRlLCByZWdleHAsIHR5cGVkYXJyYXksIGFuZCBhcnJheWJ1ZmZlciBjYW5ub3QgYmUgQlNPTiBkb2N1bWVudHNgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBwYXRoLmFkZChvYmplY3QpO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXggKyA0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2l9YDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtCU09OX1ZFUlNJT05fU1lNQk9MXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAke1N0cmluZyh2YWx1ZS5fYnNvbnR5cGUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXAgfHwgaXNNYXAob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IG9iamVjdC5lbnRyaWVzKCk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBkb25lID0gISFlbnRyeS5kb25lO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVudHJ5LnZhbHVlWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyA9PT0ga2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IGNvbnRhaW4gJy4nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbQlNPTl9WRVJTSU9OX1NZTUJPTF0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURvdWJsZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQ29kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlN5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RCUmVmJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0ludDMyJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3RvQlNPTiBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICFpZ25vcmVLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgPT09IGtleVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVVuZGVmaW5lZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN0cmluZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW0JTT05fVkVSU0lPTl9TWU1CT0xdICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RvdWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdGguZGVsZXRlKG9iamVjdCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBjb25zdCBzaXplID0gaW5kZXggLSBzdGFydGluZ0luZGV4O1xuICAgIHN0YXJ0aW5nSW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIHN0YXJ0aW5nSW5kZXgsIHNpemUpO1xuICAgIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gaXNCU09OVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdfYnNvbnR5cGUnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdzdHJpbmcnKTtcbn1cbmNvbnN0IGtleXNUb0NvZGVjcyA9IHtcbiAgICAkb2lkOiBPYmplY3RJZCxcbiAgICAkYmluYXJ5OiBCaW5hcnksXG4gICAgJHV1aWQ6IEJpbmFyeSxcbiAgICAkc3ltYm9sOiBCU09OU3ltYm9sLFxuICAgICRudW1iZXJJbnQ6IEludDMyLFxuICAgICRudW1iZXJEZWNpbWFsOiBEZWNpbWFsMTI4LFxuICAgICRudW1iZXJEb3VibGU6IERvdWJsZSxcbiAgICAkbnVtYmVyTG9uZzogTG9uZyxcbiAgICAkbWluS2V5OiBNaW5LZXksXG4gICAgJG1heEtleTogTWF4S2V5LFxuICAgICRyZWdleDogQlNPTlJlZ0V4cCxcbiAgICAkcmVndWxhckV4cHJlc3Npb246IEJTT05SZWdFeHAsXG4gICAgJHRpbWVzdGFtcDogVGltZXN0YW1wXG59O1xuZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgaW4zMkJpdFJhbmdlID0gdmFsdWUgPD0gQlNPTl9JTlQzMl9NQVggJiYgdmFsdWUgPj0gQlNPTl9JTlQzMl9NSU47XG4gICAgICAgIGNvbnN0IGluNjRCaXRSYW5nZSA9IHZhbHVlIDw9IEJTT05fSU5UNjRfTUFYICYmIHZhbHVlID49IEJTT05fSU5UNjRfTUlOO1xuICAgICAgICBpZiAob3B0aW9ucy5yZWxheGVkIHx8IG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFPYmplY3QuaXModmFsdWUsIC0wKSkge1xuICAgICAgICAgICAgaWYgKGluMzJCaXRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluNjRCaXRSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUJpZ0ludDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERvdWJsZSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodmFsdWUuJHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJyQnKSAmJiB2YWx1ZVtrXSAhPSBudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGtleXNUb0NvZGVjc1trZXlzW2ldXTtcbiAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICByZXR1cm4gYy5mcm9tRXh0ZW5kZWRKU09OKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLiRkYXRlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZCA9IHZhbHVlLiRkYXRlO1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoRGF0ZS5wYXJzZShkKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKE51bWJlcihkKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05SdW50aW1lRXJyb3IoYFVucmVjb2duaXplZCB0eXBlIGZvciBFSlNPTiBkYXRlOiAke3R5cGVvZiBkfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoRGF0ZS5wYXJzZShkKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChMb25nLmlzTG9uZyhkKSlcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZC50b051bWJlcigpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLnJlbGF4ZWQpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShOdW1iZXIoZCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OUnVudGltZUVycm9yKGBVbnJlY29nbml6ZWQgdHlwZSBmb3IgRUpTT04gZGF0ZTogJHt0eXBlb2YgZH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLiRjb2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLiRzY29wZSkge1xuICAgICAgICAgICAgY29weS4kc2NvcGUgPSBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLiRzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvZGUuZnJvbUV4dGVuZGVkSlNPTih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0RCUmVmTGlrZSh2YWx1ZSkgfHwgdmFsdWUuJGRiUG9pbnRlcikge1xuICAgICAgICBjb25zdCB2ID0gdmFsdWUuJHJlZiA/IHZhbHVlIDogdmFsdWUuJGRiUG9pbnRlcjtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEQlJlZilcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjb25zdCBkb2xsYXJLZXlzID0gT2JqZWN0LmtleXModikuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCckJykpO1xuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgICBkb2xsYXJLZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZiAoWyckcmVmJywgJyRpZCcsICckZGInXS5pbmRleE9mKGspID09PSAtMSlcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIERCUmVmLmZyb21FeHRlbmRlZEpTT04odik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KGFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodiwgaW5kZXgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wdXNoKHsgcHJvcGVydHlOYW1lOiBgaW5kZXggJHtpbmRleH1gLCBvYmo6IG51bGwgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVmFsdWUodiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRJU09TdHJpbmcoZGF0ZSkge1xuICAgIGNvbnN0IGlzb1N0ciA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSAhPT0gMCA/IGlzb1N0ciA6IGlzb1N0ci5zbGljZSgwLCAtNSkgKyAnWic7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCBpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdDYW4gb25seSBzZXJpYWxpemUgbWFwcyB3aXRoIHN0cmluZyBrZXlzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpba10gPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVWYWx1ZShvYmosIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMuc2Vlbk9iamVjdHMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5Lm9iaiA9PT0gdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IG9wdGlvbnMuc2Vlbk9iamVjdHMubWFwKGVudHJ5ID0+IGVudHJ5LnByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nUGFydCA9IHByb3BzXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAgIC5tYXAocHJvcCA9PiBgJHtwcm9wfSAtPiBgKVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlTZWVuID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgY2lyY3VsYXJQYXJ0ID0gJyAtPiAnICtcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXggKyAxLCBwcm9wcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHByb3AgPT4gYCR7cHJvcH0gLT4gYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHByb3BzW3Byb3BzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlID0gJyAnLnJlcGVhdChsZWFkaW5nUGFydC5sZW5ndGggKyBhbHJlYWR5U2Vlbi5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IGRhc2hlcyA9ICctJy5yZXBlYXQoY2lyY3VsYXJQYXJ0Lmxlbmd0aCArIChhbHJlYWR5U2Vlbi5sZW5ndGggKyBjdXJyZW50Lmxlbmd0aCkgLyAyIC0gMSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBFSlNPTjpcXG4nICtcbiAgICAgICAgICAgICAgICBgICAgICR7bGVhZGluZ1BhcnR9JHthbHJlYWR5U2Vlbn0ke2NpcmN1bGFyUGFydH0ke2N1cnJlbnR9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgICAke2xlYWRpbmdTcGFjZX1cXFxcJHtkYXNoZXN9L2ApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHNbb3B0aW9ucy5zZWVuT2JqZWN0cy5sZW5ndGggLSAxXS5vYmogPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplQXJyYXkodmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZGF0ZU51bSA9IHZhbHVlLmdldFRpbWUoKSwgaW5SYW5nZSA9IGRhdGVOdW0gPiAtMSAmJiBkYXRlTnVtIDwgMjUzNDAyMzE4ODAwMDAwO1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlbGF4ZWQgJiYgaW5SYW5nZVxuICAgICAgICAgICAgICAgID8geyAkZGF0ZTogdmFsdWUuZ2V0VGltZSgpIH1cbiAgICAgICAgICAgICAgICA6IHsgJGRhdGU6IGdldElTT1N0cmluZyh2YWx1ZSkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWxheGVkICYmIGluUmFuZ2VcbiAgICAgICAgICAgID8geyAkZGF0ZTogZ2V0SVNPU3RyaW5nKHZhbHVlKSB9XG4gICAgICAgICAgICA6IHsgJGRhdGU6IHsgJG51bWJlckxvbmc6IHZhbHVlLmdldFRpbWUoKS50b1N0cmluZygpIH0gfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKCFvcHRpb25zLnJlbGF4ZWQgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFPYmplY3QuaXModmFsdWUsIC0wKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckludDogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UNjRfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UNjRfTUFYKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkbnVtYmVyRG91YmxlOiBPYmplY3QuaXModmFsdWUsIC0wKSA/ICctMC4wJyA6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiBCaWdJbnQuYXNJbnROKDY0LCB2YWx1ZSkudG9TdHJpbmcoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIoQmlnSW50LmFzSW50Tig2NCwgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICBsZXQgZmxhZ3MgPSB2YWx1ZS5mbGFncztcbiAgICAgICAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBmbGFncyA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ4ID0gbmV3IEJTT05SZWdFeHAodmFsdWUuc291cmNlLCBmbGFncyk7XG4gICAgICAgIHJldHVybiByeC50b0V4dGVuZGVkSlNPTihvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURvY3VtZW50KHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCU09OX1RZUEVfTUFQUElOR1MgPSB7XG4gICAgQmluYXJ5OiAobykgPT4gbmV3IEJpbmFyeShvLnZhbHVlKCksIG8uc3ViX3R5cGUpLFxuICAgIENvZGU6IChvKSA9PiBuZXcgQ29kZShvLmNvZGUsIG8uc2NvcGUpLFxuICAgIERCUmVmOiAobykgPT4gbmV3IERCUmVmKG8uY29sbGVjdGlvbiB8fCBvLm5hbWVzcGFjZSwgby5vaWQsIG8uZGIsIG8uZmllbGRzKSxcbiAgICBEZWNpbWFsMTI4OiAobykgPT4gbmV3IERlY2ltYWwxMjgoby5ieXRlcyksXG4gICAgRG91YmxlOiAobykgPT4gbmV3IERvdWJsZShvLnZhbHVlKSxcbiAgICBJbnQzMjogKG8pID0+IG5ldyBJbnQzMihvLnZhbHVlKSxcbiAgICBMb25nOiAobykgPT4gTG9uZy5mcm9tQml0cyhvLmxvdyAhPSBudWxsID8gby5sb3cgOiBvLmxvd18sIG8ubG93ICE9IG51bGwgPyBvLmhpZ2ggOiBvLmhpZ2hfLCBvLmxvdyAhPSBudWxsID8gby51bnNpZ25lZCA6IG8udW5zaWduZWRfKSxcbiAgICBNYXhLZXk6ICgpID0+IG5ldyBNYXhLZXkoKSxcbiAgICBNaW5LZXk6ICgpID0+IG5ldyBNaW5LZXkoKSxcbiAgICBPYmplY3RJZDogKG8pID0+IG5ldyBPYmplY3RJZChvKSxcbiAgICBCU09OUmVnRXhwOiAobykgPT4gbmV3IEJTT05SZWdFeHAoby5wYXR0ZXJuLCBvLm9wdGlvbnMpLFxuICAgIEJTT05TeW1ib2w6IChvKSA9PiBuZXcgQlNPTlN5bWJvbChvLnZhbHVlKSxcbiAgICBUaW1lc3RhbXA6IChvKSA9PiBUaW1lc3RhbXAuZnJvbUJpdHMoby5sb3csIG8uaGlnaClcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVEb2N1bWVudChkb2MsIG9wdGlvbnMpIHtcbiAgICBpZiAoZG9jID09IG51bGwgfHwgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ25vdCBhbiBvYmplY3QgaW5zdGFuY2UnKTtcbiAgICBjb25zdCBic29udHlwZSA9IGRvYy5fYnNvbnR5cGU7XG4gICAgaWYgKHR5cGVvZiBic29udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgX2RvYyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZG9jKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wdXNoKHsgcHJvcGVydHlOYW1lOiBuYW1lLCBvYmo6IG51bGwgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplVmFsdWUoZG9jW25hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9kb2MsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2RvY1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kb2M7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvYyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBkb2MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBkb2MuX2Jzb250eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBkb2NbQlNPTl9WRVJTSU9OX1NZTUJPTF0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JTT05UeXBlKGRvYykpIHtcbiAgICAgICAgbGV0IG91dERvYyA9IGRvYztcbiAgICAgICAgaWYgKHR5cGVvZiBvdXREb2MudG9FeHRlbmRlZEpTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IEJTT05fVFlQRV9NQVBQSU5HU1tkb2MuX2Jzb250eXBlXTtcbiAgICAgICAgICAgIGlmICghbWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAnICsgZG9jLl9ic29udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXREb2MgPSBtYXBwZXIob3V0RG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnNvbnR5cGUgPT09ICdDb2RlJyAmJiBvdXREb2Muc2NvcGUpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBDb2RlKG91dERvYy5jb2RlLCBzZXJpYWxpemVWYWx1ZShvdXREb2Muc2NvcGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChic29udHlwZSA9PT0gJ0RCUmVmJyAmJiBvdXREb2Mub2lkKSB7XG4gICAgICAgICAgICBvdXREb2MgPSBuZXcgREJSZWYoc2VyaWFsaXplVmFsdWUob3V0RG9jLmNvbGxlY3Rpb24sIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2Mub2lkLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmRiLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXREb2MudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdfYnNvbnR5cGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBic29udHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVqc29uT3B0aW9ucyA9IHtcbiAgICAgICAgdXNlQmlnSW50NjQ6IG9wdGlvbnM/LnVzZUJpZ0ludDY0ID8/IGZhbHNlLFxuICAgICAgICByZWxheGVkOiBvcHRpb25zPy5yZWxheGVkID8/IHRydWUsXG4gICAgICAgIGxlZ2FjeTogb3B0aW9ucz8ubGVnYWN5ID8/IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIERvY3VtZW50IGZpZWxkIG5hbWVzIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGtleSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIGVqc29uT3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgb3B0aW9ucykge1xuICAgIGlmIChzcGFjZSAhPSBudWxsICYmIHR5cGVvZiBzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNwYWNlO1xuICAgICAgICBzcGFjZSA9IDA7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsICYmIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyByZWxheGVkOiB0cnVlLCBsZWdhY3k6IGZhbHNlIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgc2Vlbk9iamVjdHM6IFt7IHByb3BlcnR5TmFtZTogJyhyb290KScsIG9iajogbnVsbCB9XVxuICAgIH0pO1xuICAgIGNvbnN0IGRvYyA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBzZXJpYWxpemVPcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jLCByZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gRUpTT05zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIEVKU09OZGVzZXJpYWxpemUoZWpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcGFyc2UoSlNPTi5zdHJpbmdpZnkoZWpzb24pLCBvcHRpb25zKTtcbn1cbmNvbnN0IEVKU09OID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbkVKU09OLnBhcnNlID0gcGFyc2U7XG5FSlNPTi5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5FSlNPTi5zZXJpYWxpemUgPSBFSlNPTnNlcmlhbGl6ZTtcbkVKU09OLmRlc2VyaWFsaXplID0gRUpTT05kZXNlcmlhbGl6ZTtcbk9iamVjdC5mcmVlemUoRUpTT04pO1xuXG5mdW5jdGlvbiBnZXRTaXplKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE51bWJlclV0aWxzLmdldE5vbm5lZ2F0aXZlSW50MzJMRShzb3VyY2UsIG9mZnNldCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCdCU09OIHNpemUgY2Fubm90IGJlIG5lZ2F0aXZlJywgb2Zmc2V0LCB7IGNhdXNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmROdWxsKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBsZXQgbnVsbFRlcm1pbmF0b3JPZmZzZXQgPSBvZmZzZXQ7XG4gICAgZm9yICg7IGJ5dGVzW251bGxUZXJtaW5hdG9yT2Zmc2V0XSAhPT0gMHgwMDsgbnVsbFRlcm1pbmF0b3JPZmZzZXQrKylcbiAgICAgICAgO1xuICAgIGlmIChudWxsVGVybWluYXRvck9mZnNldCA9PT0gYnl0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCdOdWxsIHRlcm1pbmF0b3Igbm90IGZvdW5kJywgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxUZXJtaW5hdG9yT2Zmc2V0O1xufVxuZnVuY3Rpb24gcGFyc2VUb0VsZW1lbnRzKGJ5dGVzLCBzdGFydE9mZnNldCA9IDApIHtcbiAgICBzdGFydE9mZnNldCA/Pz0gMDtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKGBJbnB1dCBtdXN0IGJlIGF0IGxlYXN0IDUgYnl0ZXMsIGdvdCAke2J5dGVzLmxlbmd0aH0gYnl0ZXNgLCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGRvY3VtZW50U2l6ZSA9IGdldFNpemUoYnl0ZXMsIHN0YXJ0T2Zmc2V0KTtcbiAgICBpZiAoZG9jdW1lbnRTaXplID4gYnl0ZXMubGVuZ3RoIC0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgUGFyc2VkIGRvY3VtZW50U2l6ZSAoJHtkb2N1bWVudFNpemV9IGJ5dGVzKSBkb2VzIG5vdCBtYXRjaCBpbnB1dCBsZW5ndGggKCR7Ynl0ZXMubGVuZ3RofSBieXRlcylgLCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGlmIChieXRlc1tzdGFydE9mZnNldCArIGRvY3VtZW50U2l6ZSAtIDFdICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09OT2Zmc2V0RXJyb3IoJ0JTT04gZG9jdW1lbnRzIG11c3QgZW5kIGluIDB4MDAnLCBzdGFydE9mZnNldCArIGRvY3VtZW50U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgNDtcbiAgICB3aGlsZSAob2Zmc2V0IDw9IGRvY3VtZW50U2l6ZSArIHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBieXRlc1tvZmZzZXRdO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgLSBzdGFydE9mZnNldCAhPT0gZG9jdW1lbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgSW52YWxpZCAweDAwIHR5cGUgYnl0ZWAsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBuYW1lTGVuZ3RoID0gZmluZE51bGwoYnl0ZXMsIG9mZnNldCkgLSBuYW1lT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgKz0gbmFtZUxlbmd0aCArIDE7XG4gICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgIGlmICh0eXBlID09PSAxIHx8XG4gICAgICAgICAgICB0eXBlID09PSAxOCB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gOSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTcpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gNykge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTkpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTAgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDYgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDEyNyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBmaW5kTnVsbChieXRlcywgZmluZE51bGwoYnl0ZXMsIG9mZnNldCkgKyAxKSArIDEgLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gNCB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTUpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGdldFNpemUoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gNSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTIgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDEzIHx8XG4gICAgICAgICAgICB0eXBlID09PSAxNCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gZ2V0U2l6ZShieXRlcywgb2Zmc2V0KSArIDQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gNSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgSW52YWxpZCAweCR7dHlwZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX0gdHlwZSBieXRlYCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gZG9jdW1lbnRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCd2YWx1ZSByZXBvcnRzIGxlbmd0aCBsYXJnZXIgdGhhbiBkb2N1bWVudCcsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChbdHlwZSwgbmFtZU9mZnNldCwgbmFtZUxlbmd0aCwgb2Zmc2V0LCBsZW5ndGhdKTtcbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5jb25zdCBvbkRlbWFuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5vbkRlbWFuZC5wYXJzZVRvRWxlbWVudHMgPSBwYXJzZVRvRWxlbWVudHM7XG5vbkRlbWFuZC5CeXRlVXRpbHMgPSBCeXRlVXRpbHM7XG5vbkRlbWFuZC5OdW1iZXJVdGlscyA9IE51bWJlclV0aWxzO1xuT2JqZWN0LmZyZWV6ZShvbkRlbWFuZCk7XG5cbmNvbnN0IE1BWFNJWkUgPSAxMDI0ICogMTAyNCAqIDE3O1xubGV0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShNQVhTSVpFKTtcbmZ1bmN0aW9uIHNldEludGVybmFsQnVmZmVyU2l6ZShzaXplKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjaGVja0tleXMgPSB0eXBlb2Ygb3B0aW9ucy5jaGVja0tleXMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2hlY2tLZXlzIDogZmFsc2U7XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIGNvbnN0IG1pbkludGVybmFsQnVmZmVyU2l6ZSA9IHR5cGVvZiBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA6IE1BWFNJWkU7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKG1pbkludGVybmFsQnVmZmVyU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGNvbnN0IGZpbmlzaGVkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKHNlcmlhbGl6YXRpb25JbmRleCk7XG4gICAgZmluaXNoZWRCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCAwKTtcbiAgICByZXR1cm4gZmluaXNoZWRCdWZmZXI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgob2JqZWN0LCBmaW5hbEJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMuaW5kZXggPT09ICdudW1iZXInID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2VyaWFsaXphdGlvbkluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCAwLCAwLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgbnVsbCk7XG4gICAgZmluYWxCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICByZXR1cm4gc3RhcnRJbmRleCArIHNlcmlhbGl6YXRpb25JbmRleCAtIDE7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBpbnRlcm5hbERlc2VyaWFsaXplKEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgcmV0dXJuIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZShvYmplY3QsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RyZWFtKGRhdGEsIHN0YXJ0SW5kZXgsIG51bWJlck9mRG9jdW1lbnRzLCBkb2N1bWVudHMsIGRvY1N0YXJ0SW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemU6IHRydWUsIGluZGV4OiAwIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRG9jdW1lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyRGF0YSwgaW5kZXgpO1xuICAgICAgICBpbnRlcm5hbE9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZG9jdW1lbnRzW2RvY1N0YXJ0SW5kZXggKyBpXSA9IGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyRGF0YSwgaW50ZXJuYWxPcHRpb25zKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxudmFyIGJzb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEJTT05FcnJvcjogQlNPTkVycm9yLFxuICAgIEJTT05PZmZzZXRFcnJvcjogQlNPTk9mZnNldEVycm9yLFxuICAgIEJTT05SZWdFeHA6IEJTT05SZWdFeHAsXG4gICAgQlNPTlJ1bnRpbWVFcnJvcjogQlNPTlJ1bnRpbWVFcnJvcixcbiAgICBCU09OU3ltYm9sOiBCU09OU3ltYm9sLFxuICAgIEJTT05UeXBlOiBCU09OVHlwZSxcbiAgICBCU09OVmFsdWU6IEJTT05WYWx1ZSxcbiAgICBCU09OVmVyc2lvbkVycm9yOiBCU09OVmVyc2lvbkVycm9yLFxuICAgIEJpbmFyeTogQmluYXJ5LFxuICAgIENvZGU6IENvZGUsXG4gICAgREJSZWY6IERCUmVmLFxuICAgIERlY2ltYWwxMjg6IERlY2ltYWwxMjgsXG4gICAgRG91YmxlOiBEb3VibGUsXG4gICAgRUpTT046IEVKU09OLFxuICAgIEludDMyOiBJbnQzMixcbiAgICBMb25nOiBMb25nLFxuICAgIE1heEtleTogTWF4S2V5LFxuICAgIE1pbktleTogTWluS2V5LFxuICAgIE9iamVjdElkOiBPYmplY3RJZCxcbiAgICBUaW1lc3RhbXA6IFRpbWVzdGFtcCxcbiAgICBVVUlEOiBVVUlELFxuICAgIGNhbGN1bGF0ZU9iamVjdFNpemU6IGNhbGN1bGF0ZU9iamVjdFNpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplU3RyZWFtOiBkZXNlcmlhbGl6ZVN0cmVhbSxcbiAgICBvbkRlbWFuZDogb25EZW1hbmQsXG4gICAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4OiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgsXG4gICAgc2V0SW50ZXJuYWxCdWZmZXJTaXplOiBzZXRJbnRlcm5hbEJ1ZmZlclNpemVcbn0pO1xuXG5leHBvcnRzLkJTT04gPSBic29uO1xuZXhwb3J0cy5CU09ORXJyb3IgPSBCU09ORXJyb3I7XG5leHBvcnRzLkJTT05PZmZzZXRFcnJvciA9IEJTT05PZmZzZXRFcnJvcjtcbmV4cG9ydHMuQlNPTlJlZ0V4cCA9IEJTT05SZWdFeHA7XG5leHBvcnRzLkJTT05SdW50aW1lRXJyb3IgPSBCU09OUnVudGltZUVycm9yO1xuZXhwb3J0cy5CU09OU3ltYm9sID0gQlNPTlN5bWJvbDtcbmV4cG9ydHMuQlNPTlR5cGUgPSBCU09OVHlwZTtcbmV4cG9ydHMuQlNPTlZhbHVlID0gQlNPTlZhbHVlO1xuZXhwb3J0cy5CU09OVmVyc2lvbkVycm9yID0gQlNPTlZlcnNpb25FcnJvcjtcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuZXhwb3J0cy5Db2RlID0gQ29kZTtcbmV4cG9ydHMuREJSZWYgPSBEQlJlZjtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IERlY2ltYWwxMjg7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRUpTT04gPSBFSlNPTjtcbmV4cG9ydHMuSW50MzIgPSBJbnQzMjtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5leHBvcnRzLk1heEtleSA9IE1heEtleTtcbmV4cG9ydHMuTWluS2V5ID0gTWluS2V5O1xuZXhwb3J0cy5PYmplY3RJZCA9IE9iamVjdElkO1xuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5leHBvcnRzLlVVSUQgPSBVVUlEO1xuZXhwb3J0cy5jYWxjdWxhdGVPYmplY3RTaXplID0gY2FsY3VsYXRlT2JqZWN0U2l6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemVTdHJlYW0gPSBkZXNlcmlhbGl6ZVN0cmVhbTtcbmV4cG9ydHMub25EZW1hbmQgPSBvbkRlbWFuZDtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5zZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXggPSBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg7XG5leHBvcnRzLnNldEludGVybmFsQnVmZmVyU2l6ZSA9IHNldEludGVybmFsQnVmZmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJzb24uY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/bson@6.10.1/node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;